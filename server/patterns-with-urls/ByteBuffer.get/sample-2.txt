results[https://github.com/hazelcast/hazelcast/blob/f41222cbac23b683a67e1a07d1343c045ad634bb/hazelcast/src/main/java/com/hazelcast/ascii/memcache/IncrementCommand.java][writeTo][5] = -> LOOP { -> destination.put(response.get(),)@destination.hasRemaining()&&response.hasRemaining() } -> return !(response.hasRemaining())@
results[https://github.com/rafalkrupinski/jetty/blob/d3a7ddbef095e5884e33b45de34b49a236aeea45/jetty-websocket/websocket-core/src/test/java/org/eclipse/jetty/websocket/parser/MaskedByteBuffer.java][putPayload][4] = -> len=payload.remaining()@ -> LOOP { -> buffer.put((byte) payload.get()^mask[i%4],)@i<len }
results[https://github.com/kaupppa/Javnce/blob/1627fa3dfa32a894f207e847156b78c29b51a485/vnc/src/main/java/org/javnce/rfb/messages/MsgSecurityResult.java][parseData][16] = -> LOOP { -> temp.put(buffer.get(),)@0!=buffer.remaining()&&0!=temp.remaining() } -> return 0==temp.remaining()@
results[https://github.com/open-infinity/cmt/blob/165a6f88b287d62b641fa936e7760ae6744535ac/cloud/cloud-backup/src/main/java/org/openinfinity/cloud/application/backup/job/Tools.java][copyByteBuffer][1] = -> i=b1.position()@ -> LOOP { -> b2.put(b1.get(),)@i<b1.limit() }
results[https://github.com/disy/jSCSI/blob/7dc545a6574be01137cb7b88d24a4282e10282ac/jSCSI-deprecated/src/org/jscsi/parser/datasegment/AbstractDataSegment.java][setDataBuffer][2] = -> src.position(off,)@ -> LOOP { -> dataBuffer.put(src.get(),)@src.hasRemaining()&&++n<length } -> dataBuffer.rewind()@
results[https://github.com/restlet/restlet-framework-java/blob/2a89bf08ba1faf9f2f1ff09fd145fd973d2538b9/modules/org.restlet.ext.nio/src/org/restlet/ext/nio/internal/NioUtils.java][copy][2] = -> maxBuffer=Math.min(sourceBuffer.remaining(),targetBuffer.remaining(),)@ -> LOOP { -> targetBuffer.put(sourceBuffer.get(),)@ }
results[https://github.com/apache/httpcore/blob/99baa92d9a03ea2609f74a640ed5bcb47112dfa6/module-nio/src/test/java/org/apache/http/nio/mockup/ReadableByteChannelMockup.java][read][9] = -> TRY {  -> LOOP { -> dst.put(this.currentChunk.get(),)@dst.hasRemaining()&&this.currentChunk.hasRemaining() } } CATCH(IOException) {}
results[https://github.com/hazelcast/hazelcast/blob/f963f01955d48c55538ee86b08004a22232a050b/hazelcast/src/main/java/com/hazelcast/ascii/memcache/SetCommand.java][writeTo][5] = -> IF { -> response=ByteBuffer.wrap(STORED,)@response==null } -> LOOP { -> bb.put(response.get(),)@bb.hasRemaining()&&response.hasRemaining() } -> return !(response.hasRemaining())@
results[https://github.com/wordrak/kryo/blob/48b0874b7c87b1f6f5c3d2fedcb4e244ee271e46/src/main/java/com/esotericsoftware/kryo/compress/Delta.java][readMore][2] = -> tbuf.compact()@ -> LOOP { -> tbuf.put(targetBuffer.get(),)@targetBuffer.hasRemaining()&&tbuf.hasRemaining() } -> tbuf.flip()@ -> IF { -> return false@!(tbuf.hasRemaining()) }
results[https://github.com/kaupppa/Javnce/blob/83b001030b41813bf63d74d0640c11dfa95aae83/src/main/java/org/javnce/ui/fx/client/VncImage.java][rledecode][4] = -> dst=ByteBuffer.allocate(width*height*bytePerPixel,)@ -> LOOP { -> count=src.get()&0xff@rleSize<=src.remaining()&&bytePerPixel<=dst.remaining() -> src.get(pixel,)@rleSize<=src.remaining()&&bytePerPixel<=dst.remaining() -> LOOP { -> dst.put(pixel,)@rleSize<=src.remaining()&&bytePerPixel<=dst.remaining() } } -> dst.clear()@
results[https://github.com/hxzon/java-lib-hxzon/blob/ba161a9baa38c5e6c049557fb7be97745d192917/code/java/java nio/nioserver-2008-02-03/src/java/org/ronsoft/nioserver/impl/OutputQueueImpl.java][topUpBuffer][1] = -> IF { -> dest.put(src,)@src.remaining()<=dest.remaining() } ELSE { -> LOOP { -> dest.put(src.get(),)@!(src.remaining()<=dest.remaining()) && dest.hasRemaining() } }
results[https://github.com/frostwire/frostwire-android/blob/1c169f39ddd65545c8391442fc7a5dd456e7ba12/vuze/azureus2/src/com/aelitis/azureus/core/networkmanager/impl/TransportHelperFilterStreamXOR.java][cryptoOut][20] = -> TRY {  -> rem=source_buffer.remaining()@ -> LOOP { -> b=source_buffer.get()@ -> b=(byte) b^mask[++write_position]@ -> target_buffer.put(b,)@ } } CATCH(IOException) {}
results[https://github.com/alevy/comet/blob/6dc1704c63d6d912776766e9973740367280f6f5/src/dht/org/gudy/azureus2/core3/util/MD5.java][completeFinalBuffer][5] = -> LOOP { -> finalBuffer.put(buffer.get(),)@buffer.remaining()>0&&finalBuffer.remaining()>0 && !(finalBuffer.position()==0) } -> IF { -> finalBuffer.position(0,)@!(finalBuffer.position()==0) && finalBuffer.remaining()==0 -> transform(finalBuffer,)@!(finalBuffer.position()==0) && finalBuffer.remaining()==0 -> finalBuffer.position(0,)@!(finalBuffer.position()==0) && finalBuffer.remaining()==0 }
results[https://github.com/aguocool/workspace/blob/a6e10394d7333dab97fa9fc06b4231af6cbe949c/InnerClass/src/io/LockingMappedFiles.java][run][5] = -> TRY { -> LOOP { -> buff.put((byte) buff.get()+1,)@buff.position()<buff.limit()-1 } } CATCH(IOException) { -> throw new RuntimeException(e,)@ }
results[https://github.com/http-kit/http-kit/blob/c9c0b155a4ab05630d332a7d2da0aaf433889772/src/java/org/httpkit/server/WSDecoder.java][isAvailable][1] = -> LOOP { -> IF { -> tmpBuffer.put(src.get(),)@src.hasRemaining() && tmpBuffer.position()<length } ELSE { -> return false@!(src.hasRemaining()) && tmpBuffer.position()<length } } -> tmpBuffer.flip()@!(tmpBuffer.position()<length)
results[https://github.com/ybrs/hazelcastforked/blob/6d494fa5ef514816a415adb7e2e13314d67bbf87/hazelcast/src/main/java/com/hazelcast/impl/ascii/rest/HttpPostCommand.java][readLine][2] = -> LOOP { -> b=cb.get()@cb.hasRemaining() -> c=(char) b@!(cb.hasRemaining()) -> IF { -> return true@cb.hasRemaining() && c=='\n' } ELSE { -> IF { -> line.put(b,)@!(cb.hasRemaining()) && !(c=='\n') } } }
results[https://github.com/MinecraftForge/FML/blob/8844554da6d5d15756d7b0a9da2f5924006b3190/common/cpw/mods/fml/repackage/com/nothome/delta/ByteBufferSeekableSource.java][read][2] = -> TRY {  -> IF { -> return -1@!(cur.hasRemaining()) } -> LOOP { -> dest.put(cur.get(),)@cur.hasRemaining()&&dest.hasRemaining() && !(!(cur.hasRemaining())) } } CATCH(IOException) {}
results[https://github.com/teiid/teiid/blob/180dbded03a3b8f71b9340aa76f7d6fed9eae93e/engine/src/main/java/org/teiid/query/function/CharsetUtils.java][decodeLoop][1] = -> LOOP { -> bb.put(in.get(),)@in.hasRemaining() -> IF { -> IF { -> return CoderResult.OVERFLOW@in.hasRemaining() && !(bb.hasRemaining()) } -> bb.flip()@!(in.hasRemaining()) && !(bb.hasRemaining()) -> bb.clear()@!(in.hasRemaining()) && !(bb.hasRemaining()) } }
results[https://github.com/apache/avro/blob/350f09f3cefec53e20762e7862cb37f38c6251e6/lang/java/avro/src/test/java/org/apache/avro/file/codec/CustomCodec.java][decompress][2] = -> TRY {  -> out=ByteBuffer.allocate(in.remaining(),)@ -> LOOP { -> out.put((byte) ~in.get(),)@in.position()<in.capacity() } } CATCH(IOException) {}
results[https://github.com/lalithsuresh/Scaling-HDFS-NameNode/blob/afc156cc261205fcb9314c60fc89e794bcda1e79/hadoop-mapreduce-project/src/test/mapred/org/apache/hadoop/fs/slive/DataWriter.java][generatePartialSegment][56] = -> buf=ByteBuffer.wrap( new byte[],)@!(byteAm<=0) -> buf.putLong(hasher.generate(offset,),)@!(byteAm<=0) -> allBytes=ByteBuffer.wrap( new byte[],)@!(byteAm<=0) -> buf.rewind()@!(byteAm<=0) -> LOOP { -> allBytes.put(buf.get(),)@!(byteAm<=0) } -> allBytes.rewind()@!(byteAm<=0) -> return new GenerateResult(offset,allBytes,)@!(byteAm<=0)
results[https://github.com/CSEMike/OneSwarm/blob/c391e61ab70b210d10dc44ba7c172aeb96fd9d13/az_src/src/org/gudy/azureus2/core3/util/test/SHA1Old.java][completeFinalBuffer][10] = -> IF { -> return @finalBuffer.position()==0 } -> LOOP { -> finalBuffer.put(buffer.get(),)@buffer.remaining()>0&&finalBuffer.remaining()>0 && !(finalBuffer.position()==0) } -> IF { -> finalBuffer.position(0,)@!(finalBuffer.position()==0) && finalBuffer.remaining()==0 -> transform(finalBuffer,)@!(finalBuffer.position()==0) && finalBuffer.remaining()==0 -> finalBuffer.position(0,)@!(finalBuffer.position()==0) && finalBuffer.remaining()==0 }
results[https://github.com/frostwire/frostwire-desktop/blob/ad73e10b91d16904a8dcb86f7b17bb5fb45f5399/vuze/azureus2/src/org/gudy/azureus2/core3/util/SHA1.java][completeFinalBuffer][10] = -> IF { -> return @finalBuffer.position()==0 } -> LOOP { -> finalBuffer.put(buffer.get(),)@buffer.remaining()>0&&finalBuffer.remaining()>0 && !(finalBuffer.position()==0) } -> IF { -> transform(finalBuffer.array(),0,)@!(finalBuffer.position()==0) && finalBuffer.remaining()==0 -> finalBuffer.rewind()@!(finalBuffer.position()==0) && finalBuffer.remaining()==0 }
results[https://github.com/alecgorge/jsonapi/blob/8430fe66eef226fe2105a63ba9c0d16319ff31d2/src/main/java/org/java_websocket/SSLSocketChannel2.java][transfereTo][14] = -> fremain=from.remaining()@ -> toremain=to.remaining()@ -> IF { -> LOOP { -> to.put(from.get(),)@fremain>toremain } -> return limit@fremain>toremain } ELSE { -> to.put(from,)@fremain>toremain }
results[https://github.com/JetBrains/kannotator/blob/3d509f4441d13bc05542d879db745c95956ef4d1/lib/guava-13.0.1-src/com/google/common/hash/AbstractStreamingHashFunction.java][putBytes][15] = -> IF { -> buffer.put(readBuffer,)@readBuffer.remaining()<=buffer.remaining() -> return this@readBuffer.remaining()<=buffer.remaining() } -> bytesToCopy=bufferSize-buffer.position()@!(readBuffer.remaining()<=buffer.remaining()) -> LOOP { -> buffer.put(readBuffer.get(),)@!(readBuffer.remaining()<=buffer.remaining()) } -> LOOP { -> process(readBuffer,)@!(readBuffer.remaining()<=buffer.remaining()) && readBuffer.remaining()>=chunkSize } -> buffer.put(readBuffer,)@!(readBuffer.remaining()<=buffer.remaining())
results[https://github.com/disy/jSCSI/blob/7dc545a6574be01137cb7b88d24a4282e10282ac/jSCSI-deprecated/src/org/jscsi/parser/datasegment/BinaryDataSegment.java][transferBytes][2] = -> IF { -> throw new IllegalArgumentException("The given length must be less or equal than the remaining bytes in the destination buffer.",)@dst.remaining()<len } -> LOOP { -> IF { -> dst.put(src.get(),)@!(dst.remaining()<len) && !(i<len) && src.hasRemaining()&&dst.hasRemaining() } ELSE { -> throw new RuntimeException("Error by transferring the bytes in this data segment.",)@!(dst.remaining()<len) && i<len && !(src.hasRemaining()&&dst.hasRemaining()) } }
results[https://github.com/JohannesKlug/hbird/blob/2198450228fbed21fbf66fc8d7693edef3755981/src/transport/payload-codec/src/test/java/org/hbird/transport/payloadcodec/codecparameters/number/UnsignedIntegerCodecParameterTest.java][testInccorectIntTypeEncode][2] = -> LOOP { -> p.setValue(i,)@i<=MAX_UNSIGNED_BYTE -> buffer=ByteBuffer.allocate(1,)@ -> buffer.put((byte) i,).flip()@i<=MAX_UNSIGNED_BYTE -> buffer.order(ByteOrder.LITTLE_ENDIAN,)@ -> littleEndianValue=buffer.get()@ -> littleEndianBuffer=ByteBuffer.allocate(1,)@ -> littleEndianBuffer.put(littleEndianValue,)@ -> expected=BitSetUtility.fromByteArray(littleEndianBuffer.array(),)@ }
results[https://github.com/GrizzlyNIO/grizzly-mirror/blob/7a200042cae8756d47cb9a7f0702b403efebc565/modules/http/src/main/java/org/glassfish/grizzly/http/util/B2CConverter.java][flushRemainder][1] = -> LOOP { -> remainder.put(tmp_bb.get(),)@remainder.position()>0&&tmp_bb.hasRemaining() -> remainder.flip()@remainder.position()>0&&tmp_bb.hasRemaining() -> cr=decoder.decode(remainder,tmp_cb,false,)@remainder.position()>0&&tmp_bb.hasRemaining() -> IF { -> throw new IllegalStateException("CharChunk is not big enough",)@cr==CoderResult.OVERFLOW && remainder.position()>0&&tmp_bb.hasRemaining() } -> IF { -> remainder.clear()@!(cr==CoderResult.OVERFLOW) && !(remainder.hasRemaining()) && remainder.position()>0&&tmp_bb.hasRemaining() } -> remainder.compact()@!(cr==CoderResult.OVERFLOW) && remainder.position()>0&&tmp_bb.hasRemaining() }
results[https://github.com/rafalkrupinski/jetty/blob/d3a7ddbef095e5884e33b45de34b49a236aeea45/jetty-websocket/websocket-core/src/main/java/org/eclipse/jetty/websocket/parser/Parser.java][copyBuffer][1] = -> amt=Math.min(length,src.remaining(),)@ -> IF { -> mask=frame.getMask()@frame.isMasked() -> LOOP { -> dest.put((byte) src.get()^mask[i%4],)@i<amt } } ELSE { -> src.get(b,0,amt,)@ -> dest.put(b,0,amt,)@ }
results[https://github.com/samthiriot/genlab/blob/6ff6ce9e38a14397a40e3c72db10f685a4772593/genlab.graphstream.corejar/src/org/graphstream/stream/netstream/DefaultNetStreamDecoder.java][readByteArray][4] = -> TRY { -> IF { -> return null@in.read(data,0,len,)!=len } -> bb=ByteBuffer.allocate(len,)@!(in.read(data,0,len,)!=len) -> bb.put(data,)@!(in.read(data,0,len,)!=len) -> bb.flip()@!(in.read(data,0,len,)!=len) -> LOOP { -> res[i]=bb.get()@!(in.read(data,0,len,)!=len) && i<len } } CATCH(IOException) { -> debug("readBooleanArray: could not read array",)@ -> e.printStackTrace()@ }
results[https://github.com/sigmarkarl/world/blob/4fc8f09bd8c98be19a05f3bed4ff0e6f33406f2d/javafasta/src/org/java_websocket/drafts/Draft.java][readLine][17] = -> sbuf=ByteBuffer.allocate(buf.remaining(),)@ -> LOOP { -> cur=buf.get()@buf.hasRemaining() -> sbuf.put(cur,)@!(buf.hasRemaining()) -> IF { -> sbuf.limit(sbuf.position()-2,)@!(prev==(byte) '\r'&&cur==(byte) '\n') && !(buf.hasRemaining()) -> sbuf.position(0,)@!(prev==(byte) '\r'&&cur==(byte) '\n') && !(buf.hasRemaining()) -> return sbuf@buf.hasRemaining() && prev==(byte) '\r'&&cur==(byte) '\n' } } -> buf.position(buf.position()-sbuf.position(),)@!(buf.hasRemaining())
results[https://github.com/disy/jSCSI/blob/c5550dbb7fa9389f6f1afb355597ba3a2978307f/bundles/initiator/src/main/java/org/jscsi/initiator/connection/state/ReadResponseState.java][readHandleImmediateData][1] = -> TRY {  -> dataSegment=protocolDataUnit.getDataSegment()@ -> LOOP { -> buffer.put(dataSegment.get(),)@buffer.hasRemaining()&&dataSegment.hasRemaining() } -> IF { -> return @parser.getStatus()==SCSIStatus.GOOD } ELSE { -> throw new InternetSCSIException()@!(parser.getStatus()==SCSIStatus.GOOD) } } CATCH(InternetSCSIException) {}
results[https://github.com/apache/jena/blob/7d85d2b15d5d10cd3da4dc1e27d72f350842a4d4/jena-tdb/src/main/java/com/hp/hpl/jena/tdb/base/file/BufferChannelMem.java][read][1] = -> IF { -> log("read<<["+buffer.capacity()+"]",)@ } -> x=bytes.position()@ -> len=buffer.limit()-buffer.position()@ -> IF { -> len=bytes.remaining()@len>bytes.remaining() } -> LOOP { -> b=bytes.get()@ -> buffer.put(b,)@ }
results[https://github.com/svn2github/kryo/blob/5d4695ec004ee47caa42e97f92190074afd39249/src/com/esotericsoftware/kryo/io/ByteBufferInput.java][readAscii][2] = -> LOOP { -> IF { -> return readAscii_slow()@end==limit } -> b=niobuffer.get()@!(end==limit) } -> niobuffer.put(end-1,(byte) niobuffer.get(end-1,)&0x7F,)@ -> niobuffer.position(start,)@ -> niobuffer.get(tmp,)@ -> value=new String(tmp,0,0,end-start,)@ -> niobuffer.put(end-1,(byte) niobuffer.get(end-1,)|0x80,)@ -> niobuffer.position(position,)@
results[https://github.com/pagxir/antalk/blob/c0ed7ca00bd71f66ee60d3df7b28742d46f8f952/src/com/zhuri/ssl/SSLChannel.java][read][3] = -> TRY {  -> IF { -> IF { -> return appBytesProduced@appBytesProduced==-1||appBytesProduced==0 && !(peerAppData.hasRemaining()) } } -> limit=Math.min(peerAppData.remaining(),dst.remaining(),)@!(!(peerAppData.hasRemaining())) -> LOOP { -> dst.put(peerAppData.get(),)@!(!(peerAppData.hasRemaining())) } } CATCH(IOException) {}
results[https://github.com/disy/jSCSI/blob/7dc545a6574be01137cb7b88d24a4282e10282ac/jSCSI-deprecated/src/org/jscsi/parser/datasegment/AbstractDataSegment.java][next][2] = -> IF { -> throw new IllegalArgumentException()@chunkSize<0&&chunkSize>maxChunkSize } -> pos=dataBuffer.position()@!(chunkSize<0&&chunkSize>maxChunkSize) -> dataBuffer.position(cursor,)@!(chunkSize<0&&chunkSize>maxChunkSize) -> data.position(0,).limit(chunkSize,)@!(chunkSize<0&&chunkSize>maxChunkSize) -> LOOP { -> data.put(dataBuffer.get(),)@data.hasRemaining()&&dataBuffer.hasRemaining() && !(chunkSize<0&&chunkSize>maxChunkSize) } -> dataSegmentLength=data.position()@!(chunkSize<0&&chunkSize>maxChunkSize) -> data.limit(totalLength,)@!(chunkSize<0&&chunkSize>maxChunkSize) -> data.rewind()@!(chunkSize<0&&chunkSize>maxChunkSize) -> dataBuffer.position(pos,)@!(chunkSize<0&&chunkSize>maxChunkSize)
results[https://github.com/thecookie/Ardor3D/blob/55b913716a9f39f1b6998fca778450c1e6fc3f4c/ardor3d-lwjgl/src/main/java/com/ardor3d/framework/lwjgl/LwjglCanvas.java][_RGB888_to_RGBA8888][1] = -> rgb=rgb888.getData(0,)@ -> rgba8888=BufferUtils.createByteBuffer(size,)@ -> rgb.rewind()@ -> LOOP { -> IF { -> rgba8888.put((byte) 0xFF,)@ } ELSE { -> rgba8888.put(rgb.get(),)@ } } -> return new Image(Image.Format.RGBA8,rgb888.getWidth(),rgb888.getHeight(),rgba8888,)@
results[https://github.com/FoxyCorndog/WorkspaceOld/blob/495cbdb832ea4148e04db196e2c185b5b7e49fee/gafggfds/slick/src/org/newdawn/slick/openal/WaveData.java][convertAudioBytes][30] = -> dest=ByteBuffer.allocateDirect(audio_bytes.length,)@ -> dest.order(ByteOrder.nativeOrder(),)@ -> src=ByteBuffer.wrap(audio_bytes,)@ -> src.order(ByteOrder.LITTLE_ENDIAN,)@ -> IF { -> dest_short=dest.asShortBuffer()@ -> src_short=src.asShortBuffer()@ } ELSE { -> LOOP { -> dest.put(src.get(),)@src.hasRemaining() } } -> dest.rewind()@
results[https://github.com/hazelcast/hazelcast/blob/4a923f283aa641f947eed63633e1e584bf570090/hazelcast/src/main/java/com/hazelcast/nio/ascii/SocketTextReader.java][doRead][1] = -> LOOP { -> b=bb.get()@!(commandLineRead)&&bb.hasRemaining() -> c=(char) b@ } ELSE { -> IF { -> commandLine.put(b,)@ } } -> IF { -> IF { -> processCmd(toStringAndClear(commandLine,),)@ } -> IF { -> complete=command.readFrom(bb,)@command!=null } }
results[https://github.com/kaupppa/Javnce/blob/83b001030b41813bf63d74d0640c11dfa95aae83/src/main/java/org/javnce/rfb/messages/MsgServerInit.java][parseName][4] = -> IF { -> IF { -> IF { -> length=buffer.getInt()&0xFFFFFFFFL@4<=buffer.remaining() -> nameBuffer=ByteBuffer.allocate((int) length,)@null==nameBuffer } } -> LOOP { -> nameBuffer.put(buffer.get(),)@0!=buffer.remaining()&&0!=nameBuffer.remaining() } -> IF { -> nameBuffer.clear()@0==nameBuffer.remaining() -> nameBuffer.get(temp,)@0==nameBuffer.remaining() -> name=new String(temp,)@null==name } }
results[https://github.com/benruijl/WalledIn/blob/43ae595df781ae50ae96e85eefd53684dc826b04/src/walledin/game/network/client/Client.java][readDatagrams][1] = -> TRY {  -> LOOP { -> buffer.limit(BUFFER_SIZE,)@ -> buffer.rewind()@ -> channel.read(buffer,)@ -> buffer.flip()@ -> ident=buffer.getInt()@ident!=NetworkDataManager.DATAGRAM_IDENTIFICATION } -> type=buffer.get()@ -> buf=ByteBuffer.allocate(6,)@ -> buf.putInt(NetworkDataManager.DATAGRAM_IDENTIFICATION,)@ -> buf.put(NetworkDataManager.ALIVE_MESSAGE,)@ -> buf.flip()@ -> channel.write(buf,)@ } CATCH(IOException) {}
results[https://github.com/ybrs/hazelcastforked/blob/6d494fa5ef514816a415adb7e2e13314d67bbf87/hazelcast/src/main/java/com/hazelcast/nio/ascii/SocketTextReader.java][doRead][1] = -> LOOP { -> b=bb.get()@!(commandLineRead)&&bb.hasRemaining() -> c=(char) b@ } ELSE { -> IF { -> commandLine.put(b,)@ } } -> IF { -> IF { -> processCmd(toStringAndClear(commandLine,),)@ } -> IF { -> complete=command.doRead(bb,)@command!=null } }
results[https://github.com/void256/nifty-gui/blob/5cbd8e893928b49ebc29a0e7aa2e6732e63f5cc3/src/main/java/de/lessvoid/nifty/sound/openal/slick/AiffData.java][convertAudioBytes][20] = -> dest=ByteBuffer.allocateDirect(audio_bytes.length,)@ -> dest.order(ByteOrder.nativeOrder(),)@ -> src=ByteBuffer.wrap(audio_bytes,)@ -> src.order(ByteOrder.BIG_ENDIAN,)@ -> IF { -> dest_short=dest.asShortBuffer()@ -> src_short=src.asShortBuffer()@ } ELSE { -> LOOP { -> b=src.get()@src.hasRemaining() -> IF { -> b=(byte) b+127@ } -> dest.put(b,)@ } } -> dest.rewind()@
results[https://github.com/ttron/lab/blob/2139f978c863b2de04fa565a8df4d2fdbf2ceb8d/HttpCore-4.3/httpcore-nio/src/main/java/org/apache/http/nio/reactor/ssl/SSLIOSession.java][readPlain][1] = -> Args.notNull(dst,"Byte buffer",)@ -> IF { -> this.inPlain.flip()@this.inPlain.position()>0 -> n=Math.min(this.inPlain.remaining(),dst.remaining(),)@this.inPlain.position()>0 -> LOOP { -> dst.put(this.inPlain.get(),)@this.inPlain.position()>0 } -> this.inPlain.compact()@this.inPlain.position()>0 -> return n@this.inPlain.position()>0 } ELSE { -> IF { -> return -1@!(this.inPlain.position()>0) } ELSE { -> return 0@!(this.inPlain.position()>0) } }
results[https://github.com/taktod/myLib/blob/155ea22183193f12a78f19d4c799c3fbba86f425/myLib.MIT/myLib.media.vp6/src/test/java/com/ttProject/media/vp6/test/FileAnalyzeTest.java][test][1] = -> TRY {  -> LOOP { -> IF { -> IF { -> buffer=vTag.getRawData()@vTag.getCodec()==CodecType.ON2VP6 -> data=ByteBuffer.allocate(buffer.remaining(),)@ -> first=buffer.get()@ -> data.put(buffer,)@ -> data.put(first,)@ -> data.flip()@ -> dataChannel=new ByteReadChannel(data,)@ } } } } CATCH(Exception) {}
results[https://github.com/brl/netifera/blob/832c7b494b44a0de31a3ccc24f41cd091b003b18/platform/com.netifera.platform.net.wifi/com.netifera.platform.net.wifi.tools/src/com/netifera/platform/net/wifi/tools/TestWifiSniffer.java][processFrame][1] = -> IF { -> return @payload==null } -> payloadBuffer=payload.toByteBuffer()@!(payload==null) -> lineBuffer=ByteBuffer.allocate(1024,)@!(payload==null) -> LOOP { -> b=payloadBuffer.get()@!(payload==null) && payloadBuffer.remaining()>0 -> IF { -> IF { -> lineBuffer.put(b,)@!(payload==null) && lineBuffer.remaining()>0 && b>=32&&b<=126 } } ELSE { -> IF { -> lineBuffer.flip()@!(payload==null) && lineBuffer.position()>=MIN_LENGTH -> printBuffer(lineBuffer,)@!(payload==null) && lineBuffer.position()>=MIN_LENGTH } -> lineBuffer.clear()@!(payload==null) } }
results[https://github.com/apache/httpcore/blob/30658c3ef005fb2616e43186e37099c3ea315e61/httpcore-nio/src/main/java/org/apache/http/nio/reactor/ssl/SSLIOSession.java][readPlain][1] = -> Args.notNull(dst,"Byte buffer",)@ -> IF { -> inPlainBuf=this.inPlain.acquire()@this.inPlain.hasData() -> inPlainBuf.flip()@this.inPlain.hasData() -> n=Math.min(inPlainBuf.remaining(),dst.remaining(),)@this.inPlain.hasData() -> LOOP { -> dst.put(inPlainBuf.get(),)@this.inPlain.hasData() } -> inPlainBuf.compact()@this.inPlain.hasData() -> return n@this.inPlain.hasData() } ELSE { -> IF { -> return -1@!(this.inPlain.hasData()) } ELSE { -> return 0@!(this.inPlain.hasData()) } }
results[https://github.com/wallnerryan/FL_HAND/blob/86d856bef44399237ea1aa79493475acc12aff82/src/main/java/net/floodlightcontroller/packet/ICMP.java][serialize][6] = -> IF { -> payloadData=payload.serialize()@ } -> bb=ByteBuffer.wrap(data,)@ -> bb.put(this.icmpType,)@ -> bb.put(this.icmpCode,)@ -> bb.putShort(this.checksum,)@ -> IF { -> bb.put(payloadData,)@payloadData!=null } -> IF { -> bb.rewind()@ -> LOOP { -> accumulation+=0xffff&bb.getShort()@ } -> IF { -> accumulation+=bb.get()&0xff<<8@ } -> this.checksum=(short) ~accumulation&0xffff@this.checksum==0 -> bb.putShort(2,this.checksum,)@this.checksum==0 }
results[https://github.com/ttron/lab/blob/8e5b87a6d50b46fe212da99a143fd44cdf38e528/HttpCore-4.2/httpcore-nio/src/main/java/org/apache/http/nio/reactor/ssl/SSLIOSession.java][readPlain][1] = -> IF { -> throw new IllegalArgumentException("Byte buffer may not be null",)@dst==null } -> IF { -> this.inPlain.flip()@this.inPlain.position()>0 && !(dst==null) -> n=Math.min(this.inPlain.remaining(),dst.remaining(),)@this.inPlain.position()>0 && !(dst==null) -> LOOP { -> dst.put(this.inPlain.get(),)@this.inPlain.position()>0 && !(dst==null) } -> this.inPlain.compact()@this.inPlain.position()>0 && !(dst==null) -> return n@this.inPlain.position()>0 && !(dst==null) } ELSE { -> IF { -> return -1@!(this.inPlain.position()>0) && !(dst==null) } ELSE { -> return 0@!(this.inPlain.position()>0) && !(dst==null) } }
results[https://github.com/MinecraftForge/MinecraftForge/blob/e68577ffd37e91dc276fdb2933281437e594bbe3/src/main/java/paulscode/sound/codecs/CodecIBXM.java][convertAudioBytes][6] = -> dest=ByteBuffer.allocateDirect(audio_bytes.length,)@ -> dest.order(ByteOrder.nativeOrder(),)@ -> src=ByteBuffer.wrap(audio_bytes,)@ -> src.order(ByteOrder.LITTLE_ENDIAN,)@ -> IF { -> dest_short=dest.asShortBuffer()@ -> src_short=src.asShortBuffer()@ } ELSE { -> LOOP { -> dest.put(src.get(),)@src.hasRemaining() } } -> dest.rewind()@ -> IF { -> dest.get(arrayBackedBuffer,)@!(dest.hasArray()) -> dest.clear()@!(dest.hasArray()) -> return arrayBackedBuffer@!(dest.hasArray()) } -> return dest.array()@!(!(dest.hasArray()))
results[https://github.com/metamx/druid/blob/50b6888210c432304730459731bb749ff52230f3/processing/src/main/java/io/druid/query/aggregation/hyperloglog/HyperLogLogCollector.java][convertToDenseStorage][1] = -> tmpBuffer=ByteBuffer.allocateDirect(getNumBytesForDenseStorage(),)@ -> setVersion(tmpBuffer,)@ -> setRegisterOffset(tmpBuffer,getRegisterOffset(),)@ -> setNumNonZeroRegisters(tmpBuffer,getNumNonZeroRegisters(),)@ -> setMaxOverflowValue(tmpBuffer,getMaxOverflowValue(),)@ -> setMaxOverflowRegister(tmpBuffer,getMaxOverflowRegister(),)@ -> storageBuffer.position(getPayloadBytePosition(),)@ -> tmpBuffer.position(getPayloadBytePosition(tmpBuffer,),)@ -> LOOP { -> tmpBuffer.put(storageBuffer.getShort(),storageBuffer.get(),)@storageBuffer.hasRemaining() } -> tmpBuffer.rewind()@
results[https://github.com/apache/activemq/blob/c8a5fb769e9acc68f7a83c9d8b37682a4225de25/activemq-amqp/src/main/java/org/apache/activemq/transport/amqp/AmqpNioTransportHelper.java][handleAmqpHeader][1] = -> currentBuffer=ByteBuffer.allocate(8,)@ -> currentBuffer.putInt(AMQP_HEADER_VALUE,)@ -> LOOP { -> currentBuffer.put(plain.get(),)@currentBuffer.hasRemaining() } -> currentBuffer.flip()@ -> IF { -> transportSupport.doConsume(new AmqpHeader(new Buffer(currentBuffer,),),)@ } ELSE { -> transportSupport.doConsume(AmqpSupport.toBuffer(currentBuffer,),)@ } -> IF { } ELSE { -> nextFrameSize=plain.getInt()@plain.hasRemaining() && !(plain.remaining()<4) }
results[https://github.com/cml220/Cybernetic-Tiger/blob/15c8ef1f65dba02d630e714d8dd14c9fbfe2062b/04_theLeague/NextbooksFinal/pdfrenderer/com/sun/pdfview/decode/PNGPredictor.java][unpredict][1] = -> TRY {  -> LOOP { -> algorithm=(int) imageData.get()&0xff@imageData.remaining()>=rowSize+1 -> imageData.get(curLine,)@imageData.remaining()>=rowSize+1 -> doSubLine(curLine,)@ -> doUpLine(curLine,prevLine,)@ -> doAverageLine(curLine,prevLine,)@ -> doPaethLine(curLine,prevLine,)@ -> rows.add(curLine,)@ } -> outBuf=ByteBuffer.allocate(rows.size()*rowSize,)@ -> i=rows.iterator()@ -> LOOP { -> outBuf.put((byte[]) i.next(),)@i.hasNext() } -> outBuf.flip()@ } CATCH(IOException) {}
results[https://github.com/hazelcast/hazelcast/blob/4a923f283aa641f947eed63633e1e584bf570090/hazelcast/src/main/java/com/hazelcast/nio/IOUtil.java][copyToHeapBuffer][2] = -> IF { -> return 0@src==null } -> n=Math.min(src.remaining(),dest.remaining(),)@!(src==null) -> IF { -> IF { -> LOOP { -> dest.put(src.get(),)@!(src==null) } } ELSE { -> srcPosition=src.position()@!(src==null) -> destPosition=dest.position()@!(src==null) -> System.arraycopy(src.array(),srcPosition,dest.array(),destPosition,n,)@!(src==null) && n>0 && !(n<16) -> src.position(srcPosition+n,)@!(src==null) && n>0 && !(n<16) -> dest.position(destPosition+n,)@!(src==null) && n>0 && !(n<16) } }
results[https://github.com/linkedin/databus/blob/0f519041f31e234ec49525950935a50416c488e5/databus-core/databus-core-impl/src/test/java/com/linkedin/databus/core/TestDbusEventV2.java][testSerDeser][1] = -> TRY {  -> buf=ByteBuffer.allocate(maxEventLen,).order(byteOrder,)@ -> IF { -> buf.put(junk,)@ } -> eventLen=DbusEventFactory.serializeEvent(key,buf,evInfo,)@ -> evt=evt.reset(buf,bufferOffset,)@ -> bb=evt.getRawBytes()@ -> bb.get(rawEvent,)@ } ELSE { -> metadataBB=metadataPart.getData()@!(metadataPart==null) -> Assert.assertEquals(metadataBytes.length,metadataBB.remaining(),)@ -> LOOP { -> Assert.assertEquals(metadataBytes[i],metadataBB.get(),)@i<metadataBytes.length } } CATCH(Exception) {}
results[https://github.com/hxzon/java-lib-hxzon/blob/ba161a9baa38c5e6c049557fb7be97745d192917/code/java/java nio/nioserver-2008-02-03/src/java/org/ronsoft/nioserver/impl/InputQueueImpl.java][dequeueBytes][1] = -> IF { -> return emptyBuffer@buffer==null||buffer.position()==0||count==0 } -> size=Math.min(count,buffer.position(),)@!(buffer==null||buffer.position()==0||count==0) -> result=ByteBuffer.allocate(size,)@!(buffer==null||buffer.position()==0||count==0) -> buffer.flip()@!(buffer==null||buffer.position()==0||count==0) -> IF { -> result.put(buffer,)@buffer.remaining()<=result.remaining() && !(buffer==null||buffer.position()==0||count==0) } ELSE { -> LOOP { -> result.put(buffer.get(),)@!(buffer.remaining()<=result.remaining()) && !(buffer==null||buffer.position()==0||count==0) && result.hasRemaining() } } -> IF { -> bufferFactory.returnBuffer(buffer,)@!(buffer==null||buffer.position()==0||count==0) && buffer.remaining()==0 } ELSE { -> buffer.compact()@!(buffer.remaining()==0) && !(buffer==null||buffer.position()==0||count==0) } -> result.flip()@!(buffer==null||buffer.position()==0||count==0)
results[https://github.com/hugojosefson/neo4j-components-svn/blob/a269fe0b056ac7583ff0ddebb133b30870bc2750/kernel/branches/1.1-opti/src/main/java/org/neo4j/kernel/impl/nioneo/store/RelationshipTypeStore.java][rebuildIdGenerator][19] = -> TRY { -> byteBuffer=ByteBuffer.wrap( new byte[],)@ -> LOOP { -> fileChannel.read(byteBuffer,i*recordSize,)@i*recordSize<fileSize -> byteBuffer.flip()@ -> inUse=byteBuffer.get()@ -> byteBuffer.flip()@ -> IF { -> byteBuffer.clear()@ -> byteBuffer.put(Record.IN_USE.byteValue(),).putInt(Record.RESERVED.intValue(),)@ -> byteBuffer.flip()@ -> fileChannel.write(byteBuffer,i*recordSize,)@i*recordSize<fileSize -> byteBuffer.clear()@ } } } CATCH(IOException) { -> throw new UnderlyingStorageException("Unable to rebuild id generator "+getStorageFileName(),e,)@ }
results[https://github.com/commoncrawl/commoncrawl-crawler/blob/764d5621a0bbdc876ea6fdfa90cdd39e7c6367a7/src/org/commoncrawl/io/NIOBuffer.java][read][2] = -> TRY {  -> bufferOut=read()@ -> IF { -> shortBy=Math.max(0,desiredMinSize-bufferOut.remaining(),)@bufferOut!=null -> IF { -> nextBuffer=_getNextReadBuf()@ -> IF { -> bufferOut.compact()@bufferOut!=null -> IF { -> originalLimit=bufferOut.limit()@bufferOut!=null && bufferOut.capacity()-bufferOut.limit()>=shortBy&&nextBuffer.remaining()>=shortBy -> bufferOut.limit(newLimit,)@bufferOut!=null && bufferOut.capacity()-bufferOut.limit()>=shortBy&&nextBuffer.remaining()>=shortBy -> LOOP { -> bufferOut.put(originalLimit,nextBuffer.get(),)@originalLimit<newLimit && bufferOut!=null && nextBuffer!=null && bufferOut.capacity()-bufferOut.limit()>=shortBy&&nextBuffer.remaining()>=shortBy } } } } } } CATCH(IOException) {}
results[https://github.com/taktod/myLib/blob/578c2433f90a99bdeb3d95eccfa466a56f150ee3/myLib.media.mpegts/src/main/java/com/ttProject/media/mpegts/ProgramPacket.java][getBuffer][1] = -> TRY {  -> result=ByteBuffer.allocate(188,)@ -> buffer=Bit.bitConnector(bitsList.toArray( new Bit[],),)@ -> LOOP { -> data=buffer.get()@buffer.remaining()>0 -> IF { -> crc32.update(data,)@ } -> result.put(data,)@ } -> crc32Val=(int) crc32.getValue()@ -> result.put((byte) crc32Val>>>24&0xFF,)@ -> result.put((byte) crc32Val>>>16&0xFF,)@ -> result.put((byte) crc32Val>>>8&0xFF,)@ -> result.put((byte) crc32Val&0xFF,)@ -> LOOP { -> result.put((byte) 0xFF,)@result.position()!=result.limit() } -> result.flip()@ } CATCH(Exception) {}
results[https://github.com/spring-projects/spring-integration/blob/233994116c103f618c2b00ddab8965b8af423c97/org.springframework.integration.ip/src/main/java/org/springframework/integration/ip/tcp/NioSocketReader.java][assembleDataCrLfFormat][2] = -> TRY {  -> IF { -> LOOP { -> IF { -> return false@!(rawBuffer.hasRemaining()) } -> bite=rawBuffer.get()@!(!(rawBuffer.hasRemaining())) -> IF { -> buildBuffer.position(buildBuffer.position()-1,)@!(!(rawBuffer.hasRemaining())) && bite=='\n'&&buildBuffer.position()>0 -> IF { -> buildBuffer.position(buildBuffer.position()-1,)@buildBuffer.get()=='\r' && !(!(rawBuffer.hasRemaining())) && bite=='\n'&&buildBuffer.position()>0 } } -> buildBuffer.put(bite,)@!(!(rawBuffer.hasRemaining())) -> IF { -> throw new IOException("CRLF not found before max message length: "+maxMessageSize,)@!(!(rawBuffer.hasRemaining())) && buildBuffer.position()>=buildBuffer.limit() } } } } CATCH(IOException) {}
results[https://github.com/taktod/myLib/blob/c56f0987b7bb6a146d13d9b5b263aa19596db1ae/myLib.MIT/myLib.media.mpegts/src/main/java/com/ttProject/media/mpegts/ProgramPacket.java][getBuffer][1] = -> TRY {  -> result=ByteBuffer.allocate(188,)@ -> buffer=bitConnector.connect(getBits(),)@ -> LOOP { -> data=buffer.get()@buffer.remaining()>0 -> IF { -> crc32.update(data,)@ } -> result.put(data,)@ } -> crc32Val=(int) crc32.getValue()@ -> result.put((byte) crc32Val>>>24&0xFF,)@ -> result.put((byte) crc32Val>>>16&0xFF,)@ -> result.put((byte) crc32Val>>>8&0xFF,)@ -> result.put((byte) crc32Val&0xFF,)@ -> LOOP { -> result.put((byte) 0xFF,)@result.position()!=result.limit() } -> result.flip()@ } CATCH(Exception) {}
results[https://github.com/nourlcn/yarn-comment/blob/e37d2b76c787726c193e3a204bab9ce9755591cc/hadoop-mapreduce-project/hadoop-mapreduce-client/hadoop-mapreduce-client-jobclient/src/test/java/org/apache/hadoop/fs/slive/DataVerifier.java][verifyBuffer][59] = -> cmpBuf=ByteBuffer.wrap( new byte[],)@ -> LOOP { -> cmpBuf.put(buf.get(),)@ -> IF { -> cmpBuf.rewind()@!(cmpBuf.hasRemaining()) -> receivedData=cmpBuf.getLong()@!(cmpBuf.hasRemaining()) -> cmpBuf.rewind()@!(cmpBuf.hasRemaining()) } } -> IF { -> curSize=cmpBuf.position()@cmpBuf.hasRemaining()&&cmpBuf.position()!=0 -> LOOP { -> cmpBuf.put((byte) 0,)@cmpBuf.hasRemaining() && cmpBuf.hasRemaining()&&cmpBuf.position()!=0 } -> tempBuf=ByteBuffer.wrap( new byte[],)@ -> tempBuf.putLong(expected,)@ -> tempBuf.position(curSize,)@ -> LOOP { -> tempBuf.put((byte) 0,)@tempBuf.hasRemaining() } -> cmpBuf.rewind()@cmpBuf.hasRemaining()&&cmpBuf.position()!=0 -> tempBuf.rewind()@ }
results[https://github.com/apache/httpcore/blob/1e9da484b4c7bab11de3768afe1566d30ced15c0/module-nio/src/main/java/org/apache/http/impl/nio/reactor/SSLIOSession.java][readPlain][4] = -> TRY {  -> IF { -> throw new IllegalArgumentException("Byte buffer may not be null",)@dst==null } -> IF { -> this.inPlain.flip()@this.inPlain.position()>0 && !(dst==null) -> n=Math.min(this.inPlain.remaining(),dst.remaining(),)@this.inPlain.position()>0 && !(dst==null) -> LOOP { -> dst.put(this.inPlain.get(),)@this.inPlain.position()>0 && !(dst==null) } -> this.inPlain.compact()@this.inPlain.position()>0 && !(dst==null) -> return n@this.inPlain.position()>0 && !(dst==null) } ELSE { -> IF { -> return 0@!(this.inPlain.position()>0) && !(dst==null) } ELSE { -> return -1@!(this.inPlain.position()>0) && !(dst==null) } } } CATCH(SSLException) {}
results[https://github.com/desruisseaux/geotoolkit/blob/5253fb1b862ba024ec3135d3395e717aafb61fc8/modules/coverage/geotk-coverageio/src/main/java/org/geotoolkit/image/io/stream/ChannelImageInputStream.java][ensureRemaining][1] = -> TRY {  -> remaining=buffer.remaining()@ -> IF { -> p=buffer.position()@!(remaining<n) -> IF { -> LOOP { -> buffer.put(i,buffer.get(),)@i<remaining && !(remaining<n) } } -> buffer.position(remaining,).limit(buffer.capacity(),)@remaining<n -> buffer.position()<n@remaining<n -> LOOP { -> IF { -> throw new EOFException()@remaining<n && channel.read(buffer,)<=0 } } -> buffer.flip()@!(remaining<n) } } CATCH(IOException) {}
results[https://github.com/freenet/plugin-Freetalk-official/blob/492ff95d9a2724d525f1ef902244fd82bd850b2b/ui/NNTP/FreetalkNNTPHandler.java][readTextDataBytes][2] = -> TRY {  -> buf=ByteBuffer.allocate(1024,)@ -> LOOP { -> line=readLineBytes(is,)@ -> IF { -> return null@!(line.hasRemaining()) } -> IF { -> IF { -> buf.flip()@!(line.remaining()==2&&line.get(1,)=='\n'||line.remaining()==3&&line.get(1,)=='\r'&&line.get(2,)=='\n') && !(!(line.hasRemaining())) && !(line.get(0,)=='.') -> return buf@line.get(0,)=='.' && line.remaining()==2&&line.get(1,)=='\n'||line.remaining()==3&&line.get(1,)=='\r'&&line.get(2,)=='\n' && !(!(line.hasRemaining())) } ELSE { -> line.get()@line.get(0,)=='.' && !(!(line.hasRemaining())) && !(line.remaining()==2&&line.get(1,)=='\n'||line.remaining()==3&&line.get(1,)=='\r'&&line.get(2,)=='\n') } } -> IF { -> newbuf=ByteBuffer.allocate(buf.position()+line.remaining()*2,)@!(!(line.hasRemaining())) && line.remaining()>buf.remaining() && !(line.get(0,)=='.') -> buf.flip()@!(!(line.hasRemaining())) && line.remaining()>buf.remaining() && !(line.get(0,)=='.') -> newbuf.put(buf,)@!(!(line.hasRemaining())) && line.remaining()>buf.remaining() && !(line.get(0,)=='.') } -> buf.put(line,)@!(!(line.hasRemaining())) && !(line.get(0,)=='.') } } CATCH(IOException) {}
results[https://github.com/nschlimm/playground/blob/80ec4a6c8155f90fee7ea8d2b91cbef2296529be/master-playground/src/test/java/com/schlimm/master/io/nio/Buffers.java][main][1] = -> buffer=ByteBuffer.allocate(1024,)@ -> hello="Hello".getBytes()@ -> buffer.put(hello,)@ -> System.out.println("Capacity: "+buffer.capacity(),)@ -> System.out.println("Limit: "+buffer.limit(),)@ -> System.out.println("Position: "+buffer.position(),)@ -> buffer.flip()@ -> System.out.println("Capacity: "+buffer.capacity(),)@ -> System.out.println("Limit: "+buffer.limit(),)@ -> System.out.println("Position: "+buffer.position(),)@ -> LOOP { -> System.out.println((char) buffer.get(),)@buffer.hasRemaining() } -> anotherBuffer=ByteBuffer.allocate(1024,)@ -> heinz="8Bytes--".getBytes()@ -> anotherBuffer.put(heinz,)@ -> anotherBuffer.flip()@ -> System.out.println(anotherBuffer.getDouble(),)@
results[https://github.com/yudis/h2database/blob/81401dda5140b14c098a3094adb6ef09cd31a1e8/h2/src/tools/org/h2/dev/store/btree/StreamStore.java][nextBuffer][1] = -> LOOP { -> idBuffer.get()@idBuffer.hasRemaining() -> len=DataUtils.readVarInt(idBuffer,)@idBuffer.hasRemaining() -> IF { -> idBuffer.position(idBuffer.position()+len,)@skip>=len && idBuffer.hasRemaining() } -> p=(int) idBuffer.position()+skip@idBuffer.hasRemaining() -> idBuffer.position(p+l,)@idBuffer.hasRemaining() -> return new ByteArrayInputStream(idBuffer.array(),p,l,)@idBuffer.hasRemaining() -> len=DataUtils.readVarInt(idBuffer,)@idBuffer.hasRemaining() -> key=DataUtils.readVarLong(idBuffer,)@idBuffer.hasRemaining() -> return new ByteArrayInputStream(data,s,data.length-s,)@idBuffer.hasRemaining() -> len=DataUtils.readVarInt(idBuffer,)@idBuffer.hasRemaining() -> key=DataUtils.readVarLong(idBuffer,)@idBuffer.hasRemaining() -> k=store.getBlock(key,)@!(idBuffer.hasRemaining()) -> newBuffer=ByteBuffer.allocate(k.length+idBuffer.limit()-idBuffer.position(),)@idBuffer.hasRemaining() -> newBuffer.put(k,)@!(idBuffer.hasRemaining()) -> newBuffer.put(idBuffer,)@idBuffer.hasRemaining() -> newBuffer.flip()@!(idBuffer.hasRemaining()) -> return nextBuffer()@idBuffer.hasRemaining() -> throw new IllegalArgumentException("Unsupported id",)@idBuffer.hasRemaining() }
results[https://github.com/ferquies/2dam/blob/3449ac78542b4597a76f1860dc4ce81472854e44/AD/Tema 2/h2/src/main/org/h2/mvstore/StreamStore.java][nextBuffer][4] = -> LOOP { -> idBuffer.get()@idBuffer.hasRemaining() -> len=DataUtils.readVarInt(idBuffer,)@idBuffer.hasRemaining() -> IF { -> idBuffer.position(idBuffer.position()+len,)@skip>=len && idBuffer.hasRemaining() } -> p=(int) idBuffer.position()+skip@idBuffer.hasRemaining() -> idBuffer.position(p+l,)@idBuffer.hasRemaining() -> return new ByteArrayInputStream(idBuffer.array(),p,l,)@idBuffer.hasRemaining() -> len=DataUtils.readVarInt(idBuffer,)@idBuffer.hasRemaining() -> key=DataUtils.readVarLong(idBuffer,)@idBuffer.hasRemaining() -> return new ByteArrayInputStream(data,s,data.length-s,)@idBuffer.hasRemaining() -> len=DataUtils.readVarInt(idBuffer,)@idBuffer.hasRemaining() -> key=DataUtils.readVarLong(idBuffer,)@idBuffer.hasRemaining() -> k=store.getBlock(key,)@!(idBuffer.hasRemaining()) -> newBuffer=ByteBuffer.allocate(k.length+idBuffer.limit()-idBuffer.position(),)@idBuffer.hasRemaining() -> newBuffer.put(k,)@!(idBuffer.hasRemaining()) -> newBuffer.put(idBuffer,)@idBuffer.hasRemaining() -> newBuffer.flip()@!(idBuffer.hasRemaining()) -> return nextBuffer()@idBuffer.hasRemaining() -> throw DataUtils.newIllegalArgumentException("Unsupported id {0}",Arrays.toString(idBuffer.array(),),)@idBuffer.hasRemaining() }
results[https://github.com/wallnerryan/FL_HAND/blob/c4f7aca7af2970f50a71e93cbd533f165fa2e61b/src/main/java/net/floodlightcontroller/packet/UDP.java][serialize][9] = -> IF { -> payloadData=payload.serialize()@ } -> this.length=(short) 8+(payloadData==null)?0:payloadData.length@ -> bb=ByteBuffer.wrap(data,)@ -> bb.putShort(this.sourcePort,)@ -> bb.putShort(this.destinationPort,)@ -> bb.putShort(this.length,)@ -> bb.putShort(this.checksum,)@ -> IF { -> bb.put(payloadData,)@payloadData!=null } -> IF { -> bb.rewind()@ -> IF { -> accumulation+=ipv4.getSourceAddress()>>16&0xffff+ipv4.getSourceAddress()&0xffff@ -> accumulation+=ipv4.getDestinationAddress()>>16&0xffff+ipv4.getDestinationAddress()&0xffff@ -> accumulation+=ipv4.getProtocol()&0xff@ } -> LOOP { -> accumulation+=0xffff&bb.getShort()@ } -> IF { -> accumulation+=bb.get()&0xff<<8@ } -> this.checksum=(short) ~accumulation&0xffff@this.checksum==0 -> bb.putShort(6,this.checksum,)@this.checksum==0 }
results[https://github.com/svn2github/H2-Mirror/blob/af599f8ace132827af4589352bd72bc4743eba57/h2/src/main/org/h2/mvstore/StreamStore.java][nextBuffer][1] = -> LOOP { -> idBuffer.get()@idBuffer.hasRemaining() -> len=DataUtils.readVarInt(idBuffer,)@idBuffer.hasRemaining() -> IF { -> idBuffer.position(idBuffer.position()+len,)@skip>=len && idBuffer.hasRemaining() } -> p=(int) idBuffer.position()+skip@idBuffer.hasRemaining() -> idBuffer.position(p+l,)@idBuffer.hasRemaining() -> return new ByteArrayInputStream(idBuffer.array(),p,l,)@idBuffer.hasRemaining() -> len=DataUtils.readVarInt(idBuffer,)@idBuffer.hasRemaining() -> key=DataUtils.readVarLong(idBuffer,)@idBuffer.hasRemaining() -> return new ByteArrayInputStream(data,s,data.length-s,)@idBuffer.hasRemaining() -> len=DataUtils.readVarLong(idBuffer,)@idBuffer.hasRemaining() -> key=DataUtils.readVarLong(idBuffer,)@idBuffer.hasRemaining() -> k=store.getBlock(key,)@!(idBuffer.hasRemaining()) -> newBuffer=ByteBuffer.allocate(k.length+idBuffer.limit()-idBuffer.position(),)@idBuffer.hasRemaining() -> newBuffer.put(k,)@!(idBuffer.hasRemaining()) -> newBuffer.put(idBuffer,)@idBuffer.hasRemaining() -> newBuffer.flip()@!(idBuffer.hasRemaining()) -> return nextBuffer()@idBuffer.hasRemaining() -> throw DataUtils.newIllegalArgumentException("Unsupported id {0}",Arrays.toString(idBuffer.array(),),)@idBuffer.hasRemaining() }
results[https://github.com/freenet/plugin-Freetalk-staging/blob/b21b89c87bc2eca138fedf9b0224f5f273a89d60/src/plugins/Freetalk/ui/NNTP/FreetalkNNTPHandler.java][readTextDataBytes][2] = -> TRY {  -> buf=ByteBuffer.allocate(Math.max(4096,Math.min(is.available(),64*1024,),),)@ -> LOOP { -> line=readLineBytes(is,)@ -> IF { -> return null@!(line.hasRemaining()) } -> IF { -> IF { -> buf.flip()@!(line.remaining()==2&&line.get(1,)=='\n'||line.remaining()==3&&line.get(1,)=='\r'&&line.get(2,)=='\n') && !(!(line.hasRemaining())) && !(line.get(0,)=='.') -> return buf@line.get(0,)=='.' && line.remaining()==2&&line.get(1,)=='\n'||line.remaining()==3&&line.get(1,)=='\r'&&line.get(2,)=='\n' && !(!(line.hasRemaining())) } ELSE { -> line.get()@line.get(0,)=='.' && !(!(line.hasRemaining())) && !(line.remaining()==2&&line.get(1,)=='\n'||line.remaining()==3&&line.get(1,)=='\r'&&line.get(2,)=='\n') } } -> IF { -> newbuf=ByteBuffer.allocate(buf.position()+line.remaining()*2,)@!(!(line.hasRemaining())) && line.remaining()>buf.remaining() && !(line.get(0,)=='.') -> buf.flip()@!(!(line.hasRemaining())) && line.remaining()>buf.remaining() && !(line.get(0,)=='.') -> newbuf.put(buf,)@!(!(line.hasRemaining())) && line.remaining()>buf.remaining() && !(line.get(0,)=='.') } -> buf.put(line,)@!(!(line.hasRemaining())) && !(line.get(0,)=='.') } } CATCH(IOException) {}
results[https://github.com/tulskiy/musique/blob/ca8399b13c58518848aba89e9921c92f8c9d58ac/test/com/tulskiy/musique/audio/DecoderSeekTester.java][write][1] = -> IF { -> waveFile.Write(b,off,len,)@ -> TRY { -> refB.put(b,off,len,)@ } } ELSE { -> refB.mark()@ -> LOOP { -> IF { -> throw new RuntimeException("Too much samples decoded",)@refB.position()>=refB.limit() && i<off+len } -> bb=refB.get()@!(refB.position()>=refB.limit()) && !(i<off+len) -> IF { -> TRY { -> refB.reset()@!(refB.position()>=refB.limit()) && !(i<off+len) -> refB.get(frame,)@!(refB.position()>=refB.limit()) && !(i<off+len) -> f1.write(frame,)@!(refB.position()>=refB.limit()) && !(i<off+len) -> f2.write(b,off,len,)@!(refB.position()>=refB.limit()) && bb!=b[i] && i<off+len } CATCH(IOException) { -> e.printStackTrace()@!(refB.position()>=refB.limit()) && !(i<off+len) } -> fail("Not equals "+refB.position(),)@!(refB.position()>=refB.limit()) && !(i<off+len) } } } -> currentSample+=AudioMath.bytesToSamples(len,frameSize,)@
results[https://github.com/TooTallNate/Java-WebSocket/blob/2d833695699fad80313b618275f31727c618748b/src/net/tootallnate/drafts/Draft_75.java][translateFrame][2] = -> TRY {  -> LOOP { -> newestByte=buffer.get()@buffer.hasRemaining() } ELSE { -> IF { -> IF { -> curframe.setPayload(currentFrame.array(),)@this.currentFrame!=null } } ELSE { -> frame=ByteBuffer.allocate(checkAlloc((this.currentFrame!=null)?this.currentFrame.capacity():0+1,),)@ -> IF { -> this.currentFrame.rewind()@this.currentFrame!=null -> frame.put(this.currentFrame,)@this.currentFrame!=null } -> frame.put(newestByte,)@!(newestByte==START_OF_FRAME&&!(readingState)) && !(newestByte==END_OF_FRAME&&readingState) } } -> IF { -> curframe.setPayload(currentFrame.array(),)@ } } CATCH(InvalidDataException) {}
results[https://github.com/tulskiy/musique/blob/cf7c9c2678baad75443b7e33d00eef7edbf6d8df/musique-core/src/test/java/com/tulskiy/musique/audio/DecoderSeekTester.java][write][1] = -> IF { -> encoder.encode(b,len,)@ -> TRY { -> refB.put(b,off,len,)@ } } ELSE { -> refB.mark()@ -> LOOP { -> IF { -> throw new RuntimeException("Too much samples decoded",)@refB.position()>=refB.limit() && i<off+len } -> bb=refB.get()@!(refB.position()>=refB.limit()) && !(i<off+len) -> IF { -> TRY { -> refB.reset()@!(refB.position()>=refB.limit()) && !(i<off+len) -> refB.get(frame,)@!(refB.position()>=refB.limit()) && !(i<off+len) -> f1.write(frame,)@!(refB.position()>=refB.limit()) && !(i<off+len) -> f2.write(b,off,len,)@!(refB.position()>=refB.limit()) && bb!=b[i] && i<off+len } CATCH(IOException) { -> e.printStackTrace()@!(refB.position()>=refB.limit()) && !(i<off+len) } -> fail("Not equals "+refB.position(),)@!(refB.position()>=refB.limit()) && !(i<off+len) } } } -> currentSample+=AudioMath.bytesToSamples(len,frameSize,)@
results[https://github.com/perl6/nqp/blob/dd9c94acc86e522e4b53baff3af13c95921b6fda/src/vm/jvm/runtime/org/perl6/nqp/io/SyncHandle.java][getc][1] = -> TRY { -> toDecode=ByteBuffer.allocate(maxBytes,)@ -> LOOP { -> IF { -> readBuffer=ByteBuffer.allocate(32768,)@!(i<maxBytes) && readBuffer==null -> IF { -> IF { -> return ""@i<maxBytes && chan.read(readBuffer,)==-1 && readBuffer==null && i==0 } ELSE { -> toDecode.position(0,)@!(i<maxBytes) && !(chan.read(readBuffer,)==-1) && !(readBuffer==null) && i==0 -> dec.decode(toDecode,decoded,true,).throwException()@!(i<maxBytes) && !(chan.read(readBuffer,)==-1) && !(readBuffer==null) && i==0 -> return decoded.toString()@i<maxBytes && chan.read(readBuffer,)==-1 && readBuffer==null && !(i==0) } } -> readBuffer.flip()@!(i<maxBytes) && !(chan.read(readBuffer,)==-1) && readBuffer==null } -> toDecode.position(i,)@i<maxBytes && !(readBuffer==null) -> toDecode.put(readBuffer.get(),)@!(i<maxBytes) && !(readBuffer==null) -> toDecode.position(0,)@!(i<maxBytes) && !(readBuffer==null) -> cr=dec.decode(toDecode,decoded,false,)@!(i<maxBytes) && !(readBuffer==null) -> IF { -> return decoded.toString()@i<maxBytes && !(readBuffer==null) && !(cr.isError()) } } } CATCH(IOException) { -> throw ExceptionHandling.dieInternal(tc,e,)@ }
results[https://github.com/bigswitch/BeaconMirror/blob/3efdf5d1853908935728ff01ef81bac8c51886e5/net.beaconcontroller.packet/src/main/java/net/beaconcontroller/packet/UDP.java][serialize][2] = -> IF { -> payloadData=payload.serialize()@ } -> IF { -> this.length=(short) 8+(payloadData==null)?0:payloadData.length@this.length==0 } -> bb=ByteBuffer.wrap(data,)@ -> bb.putShort(this.sourcePort,)@ -> bb.putShort(this.destinationPort,)@ -> bb.putShort(this.length,)@ -> bb.putShort(this.checksum,)@ -> IF { -> bb.put(payloadData,)@payloadData!=null } -> IF { -> bb.rewind()@ -> IF { -> accumulation+=ipv4.getSourceAddress()>>16&0xffff+ipv4.getSourceAddress()&0xffff@ -> accumulation+=ipv4.getDestinationAddress()>>16&0xffff+ipv4.getDestinationAddress()&0xffff@ -> accumulation+=ipv4.getProtocol()&0xff@ } -> LOOP { -> accumulation+=0xffff&bb.getShort()@ } -> IF { -> accumulation+=bb.get()&0xff<<8@ } -> this.checksum=(short) ~accumulation&0xffff@this.checksum==0 -> bb.putShort(6,this.checksum,)@this.checksum==0 }
results[https://github.com/spring-projects/spring-integration/blob/233994116c103f618c2b00ddab8965b8af423c97/org.springframework.integration.ip/src/main/java/org/springframework/integration/ip/tcp/NioSocketReader.java][assembleDataStxEtxFormat][2] = -> TRY {  -> IF { -> bite=rawBuffer.get()@ -> IF { -> IF { -> throw new MessageMappingException("Expected STX, received "+Integer.toHexString(bite,),)@bite!=STX } -> IF { -> return false@!(bite!=STX) && !(rawBuffer.hasRemaining()) } } ELSE { -> IF { -> return true@bite==ETX } -> buildBuffer.put(bite,)@!(bite==ETX) -> IF { -> throw new IOException("ETX not found before max message length: "+maxMessageSize,)@!(bite==ETX) && buildBuffer.position()>=buildBuffer.limit() } } -> LOOP { -> IF { -> return false@!(rawBuffer.hasRemaining()) } -> bite=rawBuffer.get()@!(!(rawBuffer.hasRemaining())) -> buildBuffer.put(bite,)@!(!(rawBuffer.hasRemaining())) -> IF { -> throw new IOException("ETX not found before max message length: "+maxMessageSize,)@!(!(rawBuffer.hasRemaining())) && buildBuffer.position()>=buildBuffer.limit() } } } } CATCH(IOException) {}
results[https://github.com/zhwbqd/Java/blob/3b4adb348e1fc6ecf5bb0ec4b6c1f34d8ce420da/java_conclusion/src/main/java/zhwb/study/javabase/nio/NIOStudy.java][byteBuffer][1] = -> bf=ByteBuffer.allocate(100,)@ -> bf.put((byte) 'a',)@ -> bf.put((byte) 0>>3,)@ -> bf.putShort((short) 2<<3,)@ -> bf.putChar('a',)@ -> bf.put((byte) 'b',)@ -> bf.putInt(1,)@ -> bf.putLong(1000L,)@ -> bf.put((byte) 'H',).put((byte) 'e',).put((byte) 'l',).put((byte) 'l',).put((byte) 'o',)@ -> System.out.println("position: "+bf.position(),)@ -> System.out.println("limit: "+bf.limit(),)@ -> bf.flip()@ -> System.out.println("position: "+bf.position(),)@ -> System.out.println("limit: "+bf.limit(),)@ -> LOOP { -> outp[i]=bf.get()@bf.hasRemaining() } -> bf.rewind()@ -> System.out.println("position: "+bf.position(),)@ -> System.out.println("limit: "+bf.limit(),)@ -> System.out.println(bf.order(),)@
results[https://github.com/undertow-io/undertow/blob/cc45b5a30e7c728201decbaa3f2939dcd5ac711f/core/src/main/java/io/undertow/util/MultipartParser.java][handle][1] = -> TRY {  -> buf=resource.getResource()@ -> TRY { -> LOOP { -> b=rawData.get()@rawData.hasRemaining() -> IF { } ELSE { -> result=Character.digit((char) firstCharacter,16,)@!(firstCharacter==0) -> result+=Character.digit((char) b,16,)@ -> buf.put((byte) result,)@ } ELSE { } ELSE { -> buf.put(b,)@!(b=='=') -> IF { -> buf.flip()@!(buf.hasRemaining()) -> handler.data(buf,)@!(buf.hasRemaining()) -> buf.clear()@!(buf.hasRemaining()) } } } -> buf.flip()@ -> handler.data(buf,)@ } FINALLY { -> resource.free()@ } } CATCH(IOException) {}
results[https://github.com/sayornis/USGS-VHP/blob/c9ff26e7671aa645e504a56419dd0ab93da9b6ad/Net/src/gov/usgs/net/Server.java][processRead][1] = -> IF { -> commandBuffer=(ByteBuffer) attachment@!(!(channel.isConnected())||!(channel.isOpen())) && attachment!=null } ELSE { -> commandBuffer=ByteBuffer.allocate(COMMAND_BUFFER_SIZE,)@!(!(channel.isConnected())||!(channel.isOpen())) } -> TRY { -> inBuffer.clear()@!(!(channel.isConnected())||!(channel.isOpen())) -> i=channel.read(inBuffer,)@!(!(channel.isConnected())||!(channel.isOpen())) } ELSE { -> inBuffer.flip()@!(!(channel.isConnected())||!(channel.isOpen())) -> LOOP { -> b=inBuffer.get()@!(!(channel.isConnected())||!(channel.isOpen())) && inBuffer.position()<inBuffer.limit() -> IF { -> commandBuffer.flip()@!(!(channel.isConnected())||!(channel.isOpen())) -> cb=netTools.decoder.decode(commandBuffer,)@!(!(channel.isConnected())||!(channel.isOpen())) -> commandBuffer.clear()@!(!(channel.isConnected())||!(channel.isOpen())) } ELSE { -> commandBuffer.put(b,)@!(!(channel.isConnected())||!(channel.isOpen())) && !(b=='\n') } } -> IF { -> selectionKey.attach(commandBuffer,)@commandBuffer.position()!=0 && !(!(channel.isConnected())||!(channel.isOpen())) } } CATCH(BufferOverflowException) { -> logger.log(Level.SEVERE,"Buffer overflow on read.  Possible malicious attack?",)@!(!(channel.isConnected())||!(channel.isOpen())) } CATCH(Exception) { -> logger.log(Level.SEVERE,"Unhandled exception.",e,)@!(!(channel.isConnected())||!(channel.isOpen())) }
results[https://github.com/desruisseaux/geotoolkit-pending/blob/f96a6b0507ade4282f17c55c7d890e32c9b7d12d/modules/datastore/geotk-shapefile2/src/main/java/org/geotoolkit/index/rtree/fs/FileSystemPageStore.java][loadIndex][6] = -> TRY {  -> buf=ByteBuffer.allocate(8,)@ -> this.channel.read(buf,)@ -> buf.position(0,)@ -> headerSize=buf.getInt()@!(buf.getInt()!=FILE_VERSION) -> buf.position(0,)@!(buf.getInt()!=FILE_VERSION) -> this.header=ByteBuffer.allocate(headerSize,)@!(buf.getInt()!=FILE_VERSION) -> this.header.put(buf,)@!(buf.getInt()!=FILE_VERSION) -> this.header.mark()@!(buf.getInt()!=FILE_VERSION) -> this.channel.read(this.header,)@!(buf.getInt()!=FILE_VERSION) -> this.header.reset()@!(buf.getInt()!=FILE_VERSION) -> this.params.setMaxNodeEntries(this.header.getInt(),)@!(buf.getInt()!=FILE_VERSION) -> this.params.setMinNodeEntries(this.header.getInt(),)@!(buf.getInt()!=FILE_VERSION) -> this.params.setSplitAlg(this.header.getShort(),)@!(buf.getInt()!=FILE_VERSION) -> chLen=this.header.getInt()@!(buf.getInt()!=FILE_VERSION) -> this.header.get(bytes,)@!(buf.getInt()!=FILE_VERSION) -> dummy=charset.decode(ByteBuffer.wrap(bytes,),)@!(buf.getInt()!=FILE_VERSION) -> remaining=this.header.remaining()@!(buf.getInt()!=FILE_VERSION) -> LOOP { -> type=this.header.get()@!(buf.getInt()!=FILE_VERSION) -> IF { -> def.addField(this.header.getInt(),)@!(buf.getInt()!=FILE_VERSION) } ELSE { -> this.header.getInt()@!(buf.getInt()!=FILE_VERSION) } } -> rootOffset=this.header.getLong()@!(buf.getInt()!=FILE_VERSION) } CATCH(IOException,TreeException) {}
results[https://github.com/hazelcast/hazelcast/blob/4a923f283aa641f947eed63633e1e584bf570090/hazelcast/src/main/java/com/hazelcast/ascii/rest/HttpPostCommand.java][doActualRead][2] = -> IF { -> IF { -> hasLine=readLine(cb,)@!(chunked&&data==null||!(data.hasRemaining())) && !(readyToReadData) -> IF { -> lineStr=toStringAndClear(line,).trim()@!(chunked&&data==null||!(data.hasRemaining())) && !(readyToReadData) } -> IF { -> IF { -> return true@dataSize==0 && chunked&&data==null||!(data.hasRemaining()) && readyToReadData && hasLine } -> IF { -> newData=ByteBuffer.allocate(data.capacity()+dataSize,)@!(dataSize==0) && chunked&&data==null||!(data.hasRemaining()) && !(readyToReadData) && data!=null && !(hasLine) -> newData.put(data.array(),)@!(dataSize==0) && chunked&&data==null||!(data.hasRemaining()) && !(readyToReadData) && data!=null && !(hasLine) } ELSE { -> data=ByteBuffer.allocate(dataSize,)@!(data!=null) && !(dataSize==0) && chunked&&data==null||!(data.hasRemaining()) && !(readyToReadData) && !(hasLine) } } } -> IOUtil.copyToHeapBuffer(cb,data,)@!(chunked&&data==null||!(data.hasRemaining())) && !(readyToReadData) } -> LOOP { -> b=cb.get()@!(readyToReadData) && !(readyToReadData)&&cb.hasRemaining() -> c=(char) b@!(readyToReadData) -> IF { -> processLine(toStringAndClear(line,).toLowerCase(),)@!(readyToReadData) } ELSE { -> IF { -> line.put(b,)@!(readyToReadData) } } } -> return !(chunked)&&data!=null&&!(data.hasRemaining())@!(readyToReadData)
results[https://github.com/zhwbqd/Java/blob/678ed3fec5c74be5aef80e7f569b541abea3e148/java_conclusion/src/main/java/zhwb/study/javabase/nio/BufferStudy.java][byteBuffer][1] = -> bf=ByteBuffer.allocate(100,)@ -> bf.put((byte) 'a',)@ -> bf.put((byte) 0>>3,)@ -> bf.putShort((short) 2<<3,)@ -> bf.putChar('a',)@ -> bf.put((byte) 'b',)@ -> bf.putInt(1,)@ -> bf.putLong(1000L,)@ -> bf.put((byte) 'H',).put((byte) 'e',).put((byte) 'l',).put((byte) 'l',).put((byte) 'o',)@ -> System.out.println("position: "+bf.position()+" "+"limit: "+bf.limit(),)@ -> bf.flip()@ -> System.out.println("position: "+bf.position()+" "+"limit: "+bf.limit(),)@ -> bf.position(10,)@ -> bf.compact()@ -> System.out.println("position: "+bf.position()+" "+"limit: "+bf.limit(),)@ -> bf.flip()@ -> System.out.println("position: "+bf.position()+" "+"limit: "+bf.limit(),)@ -> LOOP { -> outp[i]=bf.get()@bf.hasRemaining() } -> bf.rewind()@ -> System.out.println("position: "+bf.position()+" "+"limit: "+bf.limit(),)@ -> System.out.println(bf.order(),)@
results[https://github.com/Mobicents/jss7/blob/3e5060bcf718b5e5989e62962755bb452759ac17/sctp/src/main/java/org/mobicents/ss7/sctp/HDLCHandler.java][processTx][1] = -> IF { -> return @this.txBuffer.isEmpty() } -> IF { -> txBufferToFill.put((byte) 0,)@!(this.txBuffer.isEmpty()) -> txBufferToFill.put((byte) 0,)@!(this.txBuffer.isEmpty()) -> txBufferToFill.put((byte) 0,)@!(this.txBuffer.isEmpty()) } -> txFrame=this.txBuffer.get(0,)@!(this.txBuffer.isEmpty()) -> i=txBufferToFill.position()@!(this.txBuffer.isEmpty()) -> LOOP { -> IF { -> IF { -> data=txFrame.get()&0xff@!(this.txBuffer.isEmpty()) && doCRC==0&&txFrame.position()<txFrame.limit() && !(i<txBufferToFill.capacity()&&!(this.txBuffer.isEmpty())) -> hdlc.fasthdlc_tx_load(txState,data,)@!(this.txBuffer.isEmpty()) && doCRC==0&&txFrame.position()<txFrame.limit() && !(i<txBufferToFill.capacity()&&!(this.txBuffer.isEmpty())) -> txCRC=PPP_FCS(txCRC,data,)@!(this.txBuffer.isEmpty()) && doCRC==0&&txFrame.position()<txFrame.limit() && !(i<txBufferToFill.capacity()&&!(this.txBuffer.isEmpty())) } ELSE { -> IF { -> hdlc.fasthdlc_tx_load_nocheck(txState,txCRC&0xff,)@!(this.txBuffer.isEmpty()) && doCRC==0&&txFrame.position()<txFrame.limit() && doCRC==1 && !(i<txBufferToFill.capacity()&&!(this.txBuffer.isEmpty())) } ELSE { -> IF { -> hdlc.fasthdlc_tx_load_nocheck(txState,txCRC>>8&0xff,)@!(this.txBuffer.isEmpty()) && doCRC==0&&txFrame.position()<txFrame.limit() && doCRC==2 && doCRC==1 && !(i<txBufferToFill.capacity()&&!(this.txBuffer.isEmpty())) } ELSE { -> hdlc.fasthdlc_tx_frame_nocheck(txState,)@!(this.txBuffer.isEmpty()) && doCRC==0&&txFrame.position()<txFrame.limit() && doCRC==2 && doCRC==1 && !(i<txBufferToFill.capacity()&&!(this.txBuffer.isEmpty())) -> IF { -> return @!(doCRC==1) && !(doCRC==2) && i<txBufferToFill.capacity()&&!(this.txBuffer.isEmpty()) && this.txBuffer.isEmpty() && !(doCRC==0&&txFrame.position()<txFrame.limit()) } ELSE { -> txFrame=this.txBuffer.get(0,)@!(this.txBuffer.isEmpty()) && i<txBufferToFill.capacity()&&!(this.txBuffer.isEmpty()) && doCRC==2 && doCRC==1 && !(doCRC==0&&txFrame.position()<txFrame.limit()) } } } } } -> txBufferToFill.put((byte) hdlc.fasthdlc_tx_run_nocheck(txState,),)@!(this.txBuffer.isEmpty()) && i<txBufferToFill.capacity()&&!(this.txBuffer.isEmpty()) }
results[https://github.com/sigmarkarl/world/blob/4fc8f09bd8c98be19a05f3bed4ff0e6f33406f2d/javafasta/src/org/java_websocket/drafts/Draft_75.java][translateRegularFrame][7] = -> TRY {  -> LOOP { -> newestByte=buffer.get()@buffer.hasRemaining() -> IF { -> IF { -> throw new InvalidFrameException("unexpected START_OF_FRAME",)@buffer.hasRemaining() && newestByte==START_OF_FRAME } } ELSE { -> IF { -> IF { -> throw new InvalidFrameException("unexpected END_OF_FRAME",)@newestByte==END_OF_FRAME && buffer.hasRemaining() && !(newestByte==START_OF_FRAME) } -> IF { -> currentFrame.flip()@newestByte==END_OF_FRAME && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && this.currentFrame!=null -> curframe.setPayload(currentFrame,)@newestByte==END_OF_FRAME && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && this.currentFrame!=null -> buffer.mark()@newestByte==END_OF_FRAME && buffer.hasRemaining() && newestByte==START_OF_FRAME } } ELSE { -> IF { -> IF { -> currentFrame=createBuffer()@newestByte==END_OF_FRAME && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && currentFrame==null } ELSE { -> IF { -> currentFrame=increaseBuffer(currentFrame,)@newestByte==END_OF_FRAME && !(currentFrame.hasRemaining()) && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && !(currentFrame==null) } } -> currentFrame.put(newestByte,)@!(newestByte==END_OF_FRAME) && !(newestByte==START_OF_FRAME) && !(buffer.hasRemaining()) } ELSE { -> return null@buffer.hasRemaining() && !(newestByte==END_OF_FRAME) && !(newestByte==START_OF_FRAME) } } } } } CATCH(InvalidDataException) {}
results[https://github.com/alecgorge/jsonapi/blob/026504f7b776ccf1d975d9b49df56bdd645fb3c0/src/org/java_websocket/drafts/Draft_75.java][translateRegularFrame][1] = -> TRY {  -> LOOP { -> newestByte=buffer.get()@buffer.hasRemaining() -> IF { -> IF { -> return null@buffer.hasRemaining() && newestByte==START_OF_FRAME } } ELSE { -> IF { -> IF { -> return null@newestByte==END_OF_FRAME && buffer.hasRemaining() && !(newestByte==START_OF_FRAME) } -> IF { -> currentFrame.flip()@newestByte==END_OF_FRAME && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && this.currentFrame!=null -> curframe.setPayload(currentFrame,)@newestByte==END_OF_FRAME && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && this.currentFrame!=null -> buffer.mark()@newestByte==END_OF_FRAME && buffer.hasRemaining() && newestByte==START_OF_FRAME } } ELSE { -> IF { -> IF { -> currentFrame=createBuffer()@newestByte==END_OF_FRAME && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && currentFrame==null } ELSE { -> IF { -> currentFrame=increaseBuffer(currentFrame,)@newestByte==END_OF_FRAME && !(currentFrame.hasRemaining()) && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && !(currentFrame==null) } } -> currentFrame.put(newestByte,)@!(newestByte==END_OF_FRAME) && !(newestByte==START_OF_FRAME) && !(buffer.hasRemaining()) } ELSE { -> return null@buffer.hasRemaining() && !(newestByte==END_OF_FRAME) && !(newestByte==START_OF_FRAME) } } } } -> IF { -> curframe.setPayload(currentFrame,)@!(buffer.hasRemaining()) } } CATCH(InvalidDataException) {}
results[https://github.com/undertow-io/undertow/blob/5bb21e256f96b5cc802f176742d56c1c07d95259/core/src/main/java/io/undertow/conduits/DeflatingStreamSinkConduit.java][flush][1] = -> TRY {  -> TRY { -> IF { } ELSE { -> buffer=currentBuffer.getResource()@ -> IF { -> data=getTrailer()@ -> IF { -> IF { -> buffer.put(data,)@data.length<=buffer.remaining() && data!=null } ELSE { -> IF { -> additionalBuffer=ByteBuffer.wrap(data,)@additionalBuffer==null && data!=null } ELSE { -> LOOP { -> newData[++pos]=additionalBuffer.get()@!(additionalBuffer==null) && additionalBuffer.hasRemaining() } -> this.additionalBuffer=ByteBuffer.wrap(newData,)@!(additionalBuffer==null) } } } } -> IF { -> buffer.flip()@ } } } FINALLY { -> IF { -> IF { -> next.resumeWrites()@ } } } } CATCH(IOException) {}
results[https://github.com/TooTallNate/Java-WebSocket/blob/fb407e530801cc88257d4c095f92ab050a5d736b/src/org/java_websocket/drafts/Draft_75.java][translateRegularFrame][7] = -> TRY {  -> LOOP { -> newestByte=buffer.get()@buffer.hasRemaining() -> IF { -> IF { -> return null@buffer.hasRemaining() && newestByte==START_OF_FRAME } } ELSE { -> IF { -> IF { -> return null@newestByte==END_OF_FRAME && buffer.hasRemaining() && !(newestByte==START_OF_FRAME) } -> IF { -> currentFrame.flip()@newestByte==END_OF_FRAME && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && this.currentFrame!=null -> curframe.setPayload(currentFrame,)@newestByte==END_OF_FRAME && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && this.currentFrame!=null -> buffer.mark()@newestByte==END_OF_FRAME && buffer.hasRemaining() && newestByte==START_OF_FRAME } } ELSE { -> IF { -> IF { -> currentFrame=createBuffer()@newestByte==END_OF_FRAME && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && currentFrame==null } ELSE { -> IF { -> currentFrame=increaseBuffer(currentFrame,)@newestByte==END_OF_FRAME && !(currentFrame.hasRemaining()) && newestByte==START_OF_FRAME && !(buffer.hasRemaining()) && !(currentFrame==null) } } -> currentFrame.put(newestByte,)@!(newestByte==END_OF_FRAME) && !(newestByte==START_OF_FRAME) && !(buffer.hasRemaining()) } ELSE { -> return null@buffer.hasRemaining() && !(newestByte==END_OF_FRAME) && !(newestByte==START_OF_FRAME) } } } } -> IF { -> currentFrame.flip()@!(buffer.hasRemaining()) -> curframe.setPayload(currentFrame,)@!(buffer.hasRemaining()) } } CATCH(InvalidDataException) {}
results[https://github.com/gec/BinaryNotes/blob/e5c93ae8bdbd62884506e9dbd362b50be9e5054f/BinaryNotesMQ/java/src/org/bn/mq/net/ASN1TransportMessageCoder.java][decode][1] = -> TRY {  -> readedBytes=buffer.limit()@ -> IF { -> data=currentDecoded.array()@currentDecoded.remaining()<readedBytes -> currentDecoded=ByteBuffer.allocate(data.length+65535+readedBytes,)@currentDecoded.remaining()<readedBytes -> currentDecoded.put(data,)@currentDecoded.remaining()<readedBytes } -> currentDecoded.put(buffer.array(),currentDecoded.position(),buffer.limit(),)@ -> lastCurrentDecodedPost=currentDecoded.position()@ -> LOOP { -> IF { -> currentDecoded.position(0,)@ -> crDecodedSchema=currentDecoded.getShort()@ -> crDecodedVersion=currentDecoded.get()@ -> crDecodedLen=currentDecoded.getInt()@ } -> IF { -> IF { -> currentDecoded.position(headerSize,)@crDecodedLen<=lastCurrentDecodedPost-headerSize -> currentDecoded.get(content,)@ -> decodedObj=decoder.decode(new ByteArrayInputStream(content,),MessageEnvelope.class,)@ -> IF { -> data=currentDecoded.array()@lastCurrentDecodedPost>currentDecoded.position() -> currentPosition=currentDecoded.position()@lastCurrentDecodedPost>currentDecoded.position() -> currentDecoded.put(data,currentPosition,lastCurrentDecodedPost-currentPosition,)@crDecodedLen<=lastCurrentDecodedPost-headerSize && lastCurrentDecodedPost>currentDecoded.position() -> lastCurrentDecodedPost=currentDecoded.position()@crDecodedLen<=lastCurrentDecodedPost-headerSize && lastCurrentDecodedPost>currentDecoded.position() -> currentDecoded.position(0,)@lastCurrentDecodedPost>currentDecoded.position() } ELSE { -> currentDecoded.clear()@!(lastCurrentDecodedPost>currentDecoded.position()) } } } } } CATCH(Exception) {}
results[https://github.com/cuckoo03/repository/blob/6697b49e8b3c1ddf5e6c964757eb65789a3e8a8f/java_networking/src/com/Exam13_5DuplicateTest.java][main][1] = -> buf=ByteBuffer.allocate(10,)@ -> buf.put((byte) 0,).put((byte) 1,).put((byte) 2,).put((byte) 3,).put((byte) 4,).put((byte) 5,).put((byte) 6,).put((byte) 7,).put((byte) 8,).put((byte) 9,)@ -> buf.position(3,)@ -> buf.limit(9,)@ -> buf.mark()@ -> buf2=buf.duplicate()@ -> System.out.println("buf2 position:"+buf2.position()+", buf2 limit:"+buf2.limit()+", buf2 capacity:"+buf2.capacity(),)@ -> buf2.position(7,)@ -> buf2.reset()@ -> System.out.println("buf2 reset() position:"+buf2.position(),)@ -> buf2.clear()@ -> System.out.println("buf2 clear() position:"+buf2.position(),)@ -> LOOP { -> System.out.print(buf2.get()+" ",)@buf2.hasRemaining() } -> System.out.println("Original buffer value:"+buf.get(0,),)@ -> System.out.println("dublication buffer value:"+buf2.get(0,),)@ -> buf.put(1,(byte) 11,)@ -> System.out.println("Original buffer value:"+buf.get(1,),)@ -> System.out.println("dublication buffer value:"+buf2.get(1,),)@
results[https://github.com/TooTallNate/Java-WebSocket/blob/fb407e530801cc88257d4c095f92ab050a5d736b/src/org/java_websocket/drafts/Draft_10.java][createBinaryFrame][15] = -> mes=framedata.getPayloadData()@ -> sizebytes=(mes.remaining()<=125)?1:(mes.remaining()<=65535)?2:8@ -> buf=ByteBuffer.allocate(1+(sizebytes>1)?sizebytes+1:sizebytes+(mask)?4:0+mes.remaining(),)@ -> one=(byte) (framedata.isFin())?-128:0@ -> buf.put(one,)@ -> payloadlengthbytes=toByteArray(mes.remaining(),sizebytes,)@ -> IF { -> buf.put((byte) (byte) payloadlengthbytes[0]|(mask)?(byte) -128:0,)@sizebytes==1 } ELSE { -> IF { -> buf.put((byte) (byte) 126|(mask)?(byte) -128:0,)@sizebytes==1 && sizebytes==2 -> buf.put(payloadlengthbytes,)@sizebytes==1 && sizebytes==2 } ELSE { -> IF { -> buf.put((byte) (byte) 127|(mask)?(byte) -128:0,)@sizebytes==1 && sizebytes==2 && sizebytes==8 -> buf.put(payloadlengthbytes,)@sizebytes==1 && sizebytes==2 && sizebytes==8 } ELSE { -> throw new RuntimeException("Size representation not supported/specified",)@!(sizebytes==2) && !(sizebytes==8) && !(sizebytes==1) } } } -> IF { -> maskkey=ByteBuffer.allocate(4,)@sizebytes==1 -> maskkey.putInt(reuseableRandom.nextInt(),)@sizebytes==1 -> buf.put(maskkey.array(),)@sizebytes==1 -> LOOP { -> buf.put((byte) mes.get()^maskkey.get(i%4,),)@sizebytes==1 && i<mes.limit() } } ELSE { -> buf.put(mes,)@sizebytes==1 } -> assert buf.remaining()@sizebytes==1 -> buf.flip()@sizebytes==1
results[https://github.com/cubieboard/openbox_sdk/blob/95a064732bb0cdea806ddd3167442c9e688eaf84/eclipse/plugins/com.android.ide.eclipse.gldebugger/src/com/android/ide/eclipse/gldebugger/CodeGen.java][codeGenDrawElements][15] = -> TRY {  -> IF { -> return @maxAttrib<1 } -> IF { -> data=msgData.msg.getData().asReadOnlyByteBuffer()@!(maxAttrib<1) -> data.order(GLFramesView.TARGET_BYTE_ORDER,)@!(maxAttrib<1) -> indexData=ByteBuffer.allocate(count*GLServerVertex.typeSize(type,),)@!(maxAttrib<1) -> indexData.order(GLFramesView.TARGET_BYTE_ORDER,)@!(maxAttrib<1) -> attribData=ByteBuffer.allocate(count*attribDataStride,)@v.indexBuffer==null||attribDataStride>0 && !(maxAttrib<1) -> attribData.order(GLFramesView.TARGET_BYTE_ORDER,)@!(maxAttrib<1) -> IF { -> indexSrc.position(msgData.msg.getArg3(),)@!(maxAttrib<1) } -> indexSrc.order(GLFramesView.TARGET_BYTE_ORDER,)@!(maxAttrib<1) -> LOOP { -> IF { -> idx=indexSrc.get()@!(maxAttrib<1) -> indexData.put(idx,)@!(maxAttrib<1) } ELSE { -> IF { -> idx=indexSrc.getShort()@!(maxAttrib<1) -> indexData.putShort(idx,)@!(maxAttrib<1) } } -> data.get(element,)@!(maxAttrib<1) -> attribData.put(element,)@!(maxAttrib<1) } -> dataOut.write(indexData.array(),)@!(maxAttrib<1) -> code.format("    %s * const indexData = (%s *)malloc(%d);\n",typeName,typeName,indexData.capacity(),)@!(maxAttrib<1) -> code.format("    fread(indexData, %d, 1, attribFile);\n",indexData.capacity(),)@!(maxAttrib<1) -> IF { -> dataOut.write(attribData.array(),)@!(maxAttrib<1) } } } CATCH(IOException) {}
results[https://github.com/develar/chromedevtools/blob/293c27ed651f2e37b2859af8ddf93acb08c1c164/platform-backend/src/org/chromium/sdk/internal/transport/LineReader.java][readLine][4] = -> TRY {  -> lineBuffer.clear()@ -> LOOP { -> IF { -> pos=buffer.position()@buffer.hasRemaining() -> chunkLen=pos-buffer.position()@buffer.hasRemaining() -> IF { -> IF { -> newSize=Math.max(lineBuffer.capacity()*2,lineBuffer.position()+chunkLen,)@chunkLen>0 && lineBuffer.remaining()<chunkLen -> newLineBuffer=ByteBuffer.allocate(newSize,)@ -> lineBuffer.flip()@lineBuffer.remaining()<chunkLen -> newLineBuffer.put(lineBuffer,)@lineBuffer.remaining()<chunkLen } -> buffer.get(lineBuffer.array(),lineBuffer.position(),chunkLen,)@buffer.hasRemaining() && chunkLen>0 -> lineBuffer.position(lineBuffer.position()+chunkLen,)@chunkLen>0 } -> IF { -> buffer.get()@buffer.hasRemaining() } } -> assert !(buffer.hasRemaining())@ -> buffer.clear()@ -> readRes=inputStream.read(buffer.array(),)@ -> IF { -> IF { -> return null@lineBuffer.position()==0 && readRes<=0 } ELSE { -> throw new IOException("End of stream while expecting line end",)@!(lineBuffer.position()==0) && readRes<=0 } } -> buffer.position(readRes,)@!(readRes<=0) -> buffer.flip()@!(readRes<=0) } -> IF { -> lineBuffer.position(lineBuffer.position()-1,)@lineBuffer.position()>0&&lineBuffer.get(lineBuffer.position()-1,)==CR_BYTE } -> return new String(lineBuffer.array(),0,lineBuffer.position(),charset,)@ } CATCH(IOException) {}
results[https://github.com/undertow-io/undertow/blob/ce84a32632d19a24548fa61b38551772864fd849/core/src/main/java/io/undertow/util/ChunkedStreamSinkChannel.java][write][1] = -> TRY {  -> TRY { -> IF { -> return 0@!(src.hasRemaining()) } -> buff=buffer.getResource()@!(!(src.hasRemaining())) -> maxSize=buff.capacity()-CHUNKING_OVERHEAD_MAX_BYTES@!(!(src.hasRemaining())) -> toWrite=Math.min(src.remaining(),maxSize,)@!(!(src.hasRemaining())) -> buff.clear()@!(!(src.hasRemaining())) -> buff.put(Integer.toHexString(toWrite,).getBytes(),)@!(!(src.hasRemaining())) -> buff.put(CRLF,)@!(!(src.hasRemaining())) -> buff.flip()@!(!(src.hasRemaining())) -> writeBuffer(buff,)@!(!(src.hasRemaining())) -> IF { -> IF { -> log.tracef("Copying into our buffer, as src size of %s was bigger than %s",src.remaining(),maxSize,)@toWrite!=src.remaining() && log.isTraceEnabled() && !(!(src.hasRemaining())) } -> buff.compact()@toWrite!=src.remaining() && !(!(src.hasRemaining())) -> LOOP { -> buff.put(src.get(),)@toWrite!=src.remaining() && !(!(src.hasRemaining())) } -> buff.put(CRLF,)@toWrite!=src.remaining() && !(!(src.hasRemaining())) -> buff.flip()@toWrite!=src.remaining() && !(!(src.hasRemaining())) -> writeBuffer(buff,)@toWrite!=src.remaining() && !(!(src.hasRemaining())) } ELSE { -> IF { -> buff.compact()@toWrite!=src.remaining() && !(!(src.hasRemaining())) && buff.hasRemaining() } ELSE { -> writeBuffer(src,)@!(!(src.hasRemaining())) && buff.hasRemaining() && !(toWrite!=src.remaining()) -> IF { -> buff.clear()@!(buff.hasRemaining()) && toWrite!=src.remaining() && !(!(src.hasRemaining())) -> buff.put(CRLF,)@!(buff.hasRemaining()) && toWrite!=src.remaining() && !(!(src.hasRemaining())) -> buff.flip()@!(buff.hasRemaining()) && toWrite!=src.remaining() && !(!(src.hasRemaining())) -> writeBuffer(buff,)@!(buff.hasRemaining()) && toWrite!=src.remaining() && !(!(src.hasRemaining())) -> return toWrite@!(src.hasRemaining()) && !(buff.hasRemaining()) && !(toWrite!=src.remaining()) } } -> buff.put(src,)@!(!(src.hasRemaining())) && buff.hasRemaining() && !(toWrite!=src.remaining()) -> buff.put(CRLF,)@toWrite!=src.remaining() && !(!(src.hasRemaining())) && buff.hasRemaining() -> buff.flip()@toWrite!=src.remaining() && !(!(src.hasRemaining())) && buff.hasRemaining() } } FINALLY { -> exit(val,FLAG_IN_WRITE|clearFlags,exitFlag,)@!(!(src.hasRemaining())) } } CATCH(IOException) {}
results[https://github.com/shnlg/TSVN/blob/c81ebdd61a3ad153ea2c592a6f9e29470d2f9de0/src/tsvn/loader/TGALoader.java][loadCompressedTGA][1] = -> TRY {  -> IF { -> throw new IOException("Invalid texture information",)@width<=0||height<=0||bpp!=24&&bpp!=32 } -> imageData=ByteBuffer.allocate(tga.imageSize,)@ -> imageData.position(0,)@ -> imageData.limit(imageData.capacity(),)@ -> colorbuffer=ByteBuffer.allocate(tga.bytesPerPixel,)@ -> LOOP { -> TRY { -> chunkHeaderBuffer=ByteBuffer.allocate(1,)@ -> fTGA.read(chunkHeaderBuffer,)@ -> chunkHeaderBuffer.flip()@ -> chunkheader=unsignedByteToInt(chunkHeaderBuffer.get(),)@ } CATCH(IOException) { -> throw new IOException("Could not read RLE header",)@ } -> IF { -> LOOP { -> readBuffer(fTGA,colorbuffer,)@ -> imageData.put(currentbyte,colorbuffer.get(2,),)@ -> imageData.put(currentbyte+1,colorbuffer.get(1,),)@ -> imageData.put(currentbyte+2,colorbuffer.get(0,),)@ -> IF { -> imageData.put(currentbyte+3,colorbuffer.get(3,),)@ } } } ELSE { -> readBuffer(fTGA,colorbuffer,)@ -> LOOP { -> imageData.put(currentbyte,colorbuffer.get(2,),)@ -> imageData.put(currentbyte+1,colorbuffer.get(1,),)@ -> imageData.put(currentbyte+2,colorbuffer.get(0,),)@ -> IF { -> imageData.put(currentbyte+3,colorbuffer.get(3,),)@ } } } } -> return createImage(width,height,imageData,bpp,)@ } CATCH(IOException) {}
results[https://github.com/OSTC/PFTT2/blob/6e253cdcbc61f7a1d7eb8b4914d2ad3d7056fbf8/src/com/ibm/icu/charset/CharsetCompoundText.java][encodeLoop][2] = -> tmpTargetBuffer=ByteBuffer.allocate(3,)@ -> IF { -> return CoderResult.UNDERFLOW@!(source.hasRemaining()) } ELSE { -> IF { -> return CoderResult.OVERFLOW@!(!(source.hasRemaining())) && !(target.hasRemaining()) } } -> LOOP { -> IF { -> IF { -> sourceChar=source.get()@!(!(target.hasRemaining())) && source.hasRemaining() && !(source.hasRemaining()) } -> tmpTargetBuffer.position(0,)@!(!(target.hasRemaining())) && !(source.hasRemaining()) -> tmpTargetBuffer.limit(3,)@!(!(target.hasRemaining())) && !(source.hasRemaining()) -> IF { -> IF { -> IF { -> IF { -> sourceChar=UCharacter.getCodePoint((char) sourceChar,trail,)@UTF16.isLeadSurrogate((char) sourceChar,)||gotoGetTrail && UTF16.isTrailSurrogate(trail,) && !(!(target.hasRemaining())) && !(source.hasRemaining()) && UTF16.isSurrogate((char) sourceChar,)||gotoGetTrail } } } } -> tmpState=getState(sourceChar,)@!(!(target.hasRemaining())) && !(source.hasRemaining()) -> sourceCharArray[0]=(char) sourceChar@!(!(target.hasRemaining())) && !(source.hasRemaining()) -> IF { -> LOOP { -> err=gbEncoder[i].cnvMBCSFromUnicodeWithOffsets(CharBuffer.wrap(sourceCharArray,),tmpTargetBuffer,offsets,true,)@!(!(target.hasRemaining())) && i<SEARCH_LENGTH && !(source.hasRemaining()) -> IF { -> tmpState=(byte) i@!(!(target.hasRemaining())) && tmpState<0 && i<SEARCH_LENGTH && !(source.hasRemaining()) -> tmpTargetBuffer.limit(tmpTargetBuffer.position(),)@!(!(target.hasRemaining())) && !(source.hasRemaining()) } } } ELSE { -> IF { -> tmpTargetBuffer.put(0,(byte) sourceChar,)@!(!(target.hasRemaining())) && !(source.hasRemaining()) -> tmpTargetBuffer.limit(1,)@!(!(target.hasRemaining())) && !(source.hasRemaining()) } ELSE { -> err=gbEncoder[tmpState].cnvMBCSFromUnicodeWithOffsets(CharBuffer.wrap(sourceCharArray,),tmpTargetBuffer,offsets,true,)@!(tmpState==COMPOUND_TEXT_SINGLE_0) && !(!(target.hasRemaining())) && !(tmpState<0) && !(source.hasRemaining()) -> IF { -> tmpTargetBuffer.limit(tmpTargetBuffer.position(),)@!(!(target.hasRemaining())) && !(source.hasRemaining()) } } } -> LOOP { -> targetBytes[i+targetLength]=tmpTargetBuffer.get(i,)@!(!(target.hasRemaining())) && i<tmpTargetBuffer.limit() && !(source.hasRemaining()) } -> LOOP { -> IF { -> target.put(targetBytes[i],)@i<targetLength && !(!(target.hasRemaining())) && target.hasRemaining() && !(source.hasRemaining()) } } } }
results[https://github.com/rektide/waterken-mirror/blob/6abadd762007353fc49f3478eb1fbf05e4c1c7a6/waterken/k2v/src/org/k2v/trie/Trie.java][readNext][2] = -> TRY {  -> LOOP { -> IF { -> throw new NoSuchElementException()@stack.isEmpty() } -> node=stack.get(stack.size()-1,)@!(stack.isEmpty()) -> IF { -> stack.remove(stack.size()-1,)@!(stack.isEmpty()) } -> rwkey.limit(node.depth,)@!(stack.isEmpty()) -> rokey.limit(rwkey.limit(),)@!(stack.isEmpty()) -> IF { -> rwkey.put(node.depth-1,node.heads.get(),)@!(stack.isEmpty()) } -> LOOP { -> run=read(size,at,)@!(stack.isEmpty()) -> ref=value(run,RunBranch,)@!(stack.isEmpty()) -> IF { -> rwkey=ByteBuffer.allocate(2*rwkey.limit()+length,).put(rwkey,)@!(stack.isEmpty()) && rwkey.limit()+length>rwkey.capacity() -> rokey=rwkey.asReadOnlyBuffer()@!(stack.isEmpty()) && rwkey.limit()+length>rwkey.capacity() } -> rwkey.limit(rwkey.limit()+length,)@!(stack.isEmpty()) -> rokey.limit(rwkey.limit(),)@!(stack.isEmpty()) -> run.rewind().limit(length,)@!(stack.isEmpty()) -> rwkey.put(run,)@!(stack.isEmpty()) } -> IF { -> IF { -> rwkey=ByteBuffer.allocate(2*rwkey.limit()+1,).put(rwkey,)@isAMap(type,) && !(stack.isEmpty()) && rwkey.limit()==rwkey.capacity() -> rokey=rwkey.asReadOnlyBuffer()@isAMap(type,) && !(stack.isEmpty()) && rwkey.limit()==rwkey.capacity() } -> stack.add(new Node(rwkey.limit()+1,listMap(map,arity,),(ByteBuffer) ByteBuffer.allocate(map.remaining(),).put(map,).rewind(),),)@isAMap(type,) && !(stack.isEmpty()) } ELSE { -> IF { -> leaf=read(SizeOfLeaf,at,)@isAMap(type,) && TypeOfLeaf==type && !(stack.isEmpty()) -> child=value(leaf,LeafChild,)@isAMap(type,) && TypeOfLeaf==type && !(stack.isEmpty()) -> depth=rwkey.limit()@isAMap(type,) && TypeOfLeaf==type && !(stack.isEmpty()) -> stack.add(new Node(depth,(0==depth)?null:ByteBuffer.allocate(1,).put(0,rwkey.get(depth-1,),),ByteBuffer.allocate(8,).putLong(0,value(leaf,LeafBranch,),),),)@isAMap(type,) && TypeOfLeaf==type && !(stack.isEmpty()) -> return rokey@TypeOfLeaf==type && !(stack.isEmpty()) && !(isAMap(type,)) } ELSE { -> return rokey@!(stack.isEmpty()) && !(isAMap(type,)) && !(TypeOfLeaf==type) } } } } CATCH(IOException) {}
results[https://github.com/johnnyeven/godwar-server/blob/6ef62db2bcfda57021dd0783d0f36a6ce986f63f/GodwarLogicServer/src/com/xgame/server/logic/GameServerHolderThread.java][requestLogicServerRoom][1] = -> LOOP { -> length=buffer.getInt()@buffer.hasRemaining() -> type=buffer.get()@buffer.hasRemaining() -> IF { -> IF { -> roomType=buffer.getInt()@roomType==Integer.MIN_VALUE && buffer.hasRemaining() } ELSE { -> IF { -> roomId=buffer.getInt()@roomId==Integer.MIN_VALUE && buffer.hasRemaining() } ELSE { -> IF { -> peopleCount=buffer.getInt()@peopleCount==Integer.MIN_VALUE && buffer.hasRemaining() } ELSE { -> IF { -> playerGroup=buffer.getInt()@buffer.hasRemaining() && playerGroup==Integer.MIN_VALUE } ELSE { -> IF { -> playerPosition=buffer.getInt()@buffer.hasRemaining() && playerPosition==Integer.MIN_VALUE } } } } } } ELSE { -> IF { -> IF { -> buffer.get(dst,)@buffer.hasRemaining() -> TRY { -> roomTitle=new String(dst,"UTF-8",)@roomTitle==null } CATCH(UnsupportedEncodingException) { -> e.printStackTrace()@ } } ELSE { -> IF { -> buffer.get(dst,)@buffer.hasRemaining() -> TRY { -> ownerGuid=new String(dst,"UTF-8",)@ownerGuid==null } CATCH(UnsupportedEncodingException) { -> e.printStackTrace()@ } } ELSE { -> IF { -> IF { -> buffer.get(dst,)@buffer.hasRemaining() -> TRY { -> playerGuid=new String(dst,"UTF-8",)@playerGuid==null } CATCH(UnsupportedEncodingException) { -> e.printStackTrace()@ } } ELSE { -> IF { -> buffer.get(dst,)@buffer.hasRemaining() -> TRY { -> heroCardId=new String(dst,"UTF-8",)@heroCardId==null } CATCH(UnsupportedEncodingException) { -> e.printStackTrace()@ } } } } } } } } } -> IF { -> IF { -> bf=BufferPool.getInstance().getBuffer()@ -> bf.putShort(EnumProtocol.BASE_REQUEST_LOGIC_SERVER_ROOM_CONFIRM,)@ -> bf.putInt(4,)@ -> bf.put((byte) EnumProtocol.TYPE_INT,)@ -> bf.putInt(roomType,)@roomType==0 -> bf.putInt(4,)@ -> bf.put((byte) EnumProtocol.TYPE_INT,)@ -> bf.putInt(roomId,)@ -> bf.flip()@ -> bf.get(dest,0,dest.length,)@ -> p.setData(dest,)@ } }
results[https://github.com/xylifyx/ippclient/blob/db215cb7cba946ab28df688979ac1dc1788dfc15/src/ch/ethz/vppserver/ippclient/dispatch/ResponseHandler.java][getChunkBuffer][2] = -> b=ByteBuffer.allocate(BUFSIZE,)@ -> LOOP { } ELSE { -> LOOP { -> b.put(buf.get(),)@ } } -> b.flip()@
results[https://github.com/Aldeon/Aldeon/blob/4173391b42ffb0c6058a81135765a5b8fb208978/src/main/java/org/aldeon/utils/helpers/ByteBuffers.java][xor][1] = -> a=a.asReadOnlyBuffer()@ -> b=b.asReadOnlyBuffer()@ -> c=ByteBuffer.allocate(a.remaining(),)@ -> LOOP { -> vc=0xFF&a.get()^b.get()@a.hasRemaining() -> c.put((byte) vc,)@ } -> c.flip()@
results[https://github.com/shaoxr/beecode/blob/1b9413b7aec5fb0e2e7bad4f551d8e70b4f0bf55/src/main/java/com/newland/posp/mina/boc/DepotPosProtocolEncoder.java][appendCheckValue][1] = -> buffer.position(from,)@ -> LOOP { -> IF { -> check[i]=buffer.get()@i<8 && i<to-from } ELSE { -> check[i%8]^=buffer.get()@!(i<8) && i<to-from } } -> LOOP { -> buffer.put(check[i],)@i<4 }
