% ==============================================
% !TEX root = ./critics.tex
% ==============================================
% ==============================================
\section{Implementation}
\label{sec:implementation}
% ==============================================
\todo{Overall, I feel this section talks too much about the UI design and the communicate between front-end and back-end, e.g., how we structure the data in a JSON message and how the front-end handles such JSON messages, etc. We have already talked a lot about UI design in the motivating example section. In this section, we need to provide technical depth about how we process SO snippets and generate the data that the front-end renders (e.g., violations, descriptive warning message, pattern contextualization).}
\todo{I hope Figure~\ref{fig:arch} can reflect each component in the front-end and back-end design. And the description in this section can also naturally map to Figure~\ref{fig:arch}.}
%\todo{Please also update the figure references using latex reference command in this section.}
This section describes the implementation details of {\soa}. The front-end is implemented as a Chrome extension and the back-end is set up in an Apache server. {\soa} consists of five components: (1) Stack Overflow code snippet extraction, (2) API misuse detection, (3) popup generation, (4) GitHub example alteration, and (5) a user feedback interface.

{\bf Code Snippet Extraction.} When a user loads a Stack Overflow webpage, the Chrome extension extracts code snippets within {\tt <code>} tags in answer posts, and sends them in a JSON message to the server, as seen in Figure~\ref{fig:arch}.

{\bf API Misuse Detection.} When the server receives a message from the plug-in, it parses the snippets into API call sequences, abstracting away irrelevant statements and syntactic details. An API call sequence consists of relevant control constructs and API calls, where the API calls are annotated with the number of arguments as well as any guard conditions associated with it.

%\todo{Instead of directly saying that {\soa} searchs for patterns from a MySQL database, we should first explain that we bootstrap {\soa}'s pattern database with mined patterns of 30 well-studied Java and Android APIs. We should also explain that {\soa} will automatically issue another mining request and expand the database with new patterns when encountering a new API that does not exist in our database.}
{\it Pattern Mining.} 
%\todo{Can you use one paragraph to briefly summarize the pattern mining technique?}
Once the code snippets are parsed, {\soa} searches its pattern database for the API calls present in each API call sequence. {\soa}'s pattern database is bootstrapped with mined patterns of 30 well-studied Java and Android APIs. When {\soa} encounters a new API that does not exist in its database, it automatically issues another mining request and expands the database with the new patterns it finds. Specifically, {\soa} utilizes a distributed software mining infrastructure, Boa \todo{cite} to traverse the abstract syntax trees (ASTs) of 7 million Java projects, collected September 2015 from GitHub. For every AST method, {\soa} checks if it is from the API of interest. If it is, {\soa} translates the code snippet into a structured call sequence. From these call sequences, {\soa} finds a common subsequence which is the required pattern for that API method, and this is added to the database.

When {\soa} receives the required and alternative patterns associated with the specified API calls, it checks whether the code snippet's call sequence satisfies one of the alternative patterns and all required patterns. A code snippet's call sequence satisfies a pattern if it is subsumed by it.

Additionally, while this checking process is occurring, the guard conditions in the code snippets are generalized before checking their logical implications using the SMT solver Z3. Z3 is used to check the logical equivalence between two guard conditions so that {\soa} can merge logically-similar clusters of guard conditions.
%\todo{Shortern this description about Z3 to maybe one or two sentences.}

If {\soa} finds that an API call sequence does not satisfy the necessary patterns, it generates violations for each potential API misuse and returns them to the plug-in.
%\todo{It is not necessary to describe how we wrap the data and communicate with the front-end. Please shorten this paragraph.}

{\bf Popup Generation.} Using the data from the server's JSON message, the plug-in searches the identified code snippet for the API call in question, highlights it, and generates a Bootstrap popover on it, as seen in Figure~\ref{fig:features}. The popover is populated with a violation message describing the pattern being violated and including the GitHub support for the required pattern, in terms of number of supporting projects as well as three links to relevant GitHub pages using that pattern correctly. The plug-in generates one popover for each API call, and generates pages of the popover for each different pattern being violated by that call. The provided example of the pattern is currently hard-coded.\todo{We need to provide more details about how to generate the text description of each violation, e.g., showing the templates in a table.}

{\bf Pattern Contextualization.} \todo{Describe how we generate a correct example based on the context of the assessed SO example to demonstrate the correct API usage?}

{\bf GitHub Example Alteration.} When the user clicks on a provided GitHub example in the popup, the plug-in's main script writes the name of the method call associated with that link to a shared storage space for the Chrome extension, using the {\tt chrome.storage} API. The script highlights the entire method and scrolls the view down so the user is easily able to find it, as seen in Figure~\ref{fig:github_examples}.
%\todo{Too much details about the Chrome extension.}

{\bf User Feedback.} Users are able to give feedback on the patterns the popup shows them by voting "up" or "down" on them. When a vote is registered, the plug-in sends the server a message with the pattern's specific ID and a vote of +1 or -1, which the server uses to update the database. This will be used in the future to rank patterns that are sent to the plug-in, and learn which ones users find helpful or unhelpful.