% ==============================================
% !TEX root = ./critics.tex
% ==============================================
% ==============================================
\section{Implementation}
\label{sec:implementation}
% ==============================================

This section describes the implementation details of {\tool}. Figure~\ref{fig:arch} shows the architecture of {\tool}.  When a user loads a Stack Overflow page in the Chrome browser, the Chrome extension extracts code snippets within {\ttt <code>} tags in answer posts, and sends them to the back-end server in a {\ttt JSON} message. The back end then detects API usage violations in a snippet and synthesizes violation descriptions and fixes. For each misused method call in a snippet, the Chrome extension generates a pop-up window using the Bootstrap popover plug-in\footnote{\url{https://www.w3schools.com/bootstrap/bootstrap_popover.asp}} to visualize the violation information received from the server.

{\bf API Usage Pattern Dataset.} {\tool}'s dataset of API usage patterns includes 180 patterns of 100 popular Java API methods in Stack Overflow. These patterns are learned from 380K GitHub repositories and are represented as API call sequences with surrounding control constructs. Each API call in a sequence is also annotated with the argument types and guard conditions. For example, one pattern, {\ttt loop \{; get(int)@arg0$<$rcv.size(); \}}, checks if the index is out of bounds when calling the {\ttt get} method on an {\ttt ArrayList} object. The pattern format and the mining algorithm are described in a separate technical report.\todo{cite Maple} The current dataset can be extended with API usage patterns learned from other mining techniques~\cite{gruska2010learning, wang2013mining, zhong2009mapo, Nguyen09}. 

{\bf API Misuse Detection.} The back end first extracts API call sequences from the snippets sent by the Chrome extension using a partial program analysis framework that handles incomplete snippets with no class or method headers~\cite{subramanian2014live}. {\tool} then searches its pattern database for the API calls present in each API call sequence. Given an API call sequence and an API usage pattern, it checks whether (1)  the pattern is a subsequence of the API call sequence, and (2) the guard condition of each API call in the sequence implies the guard of the corresponding API call in the pattern. {\tool} uses a SMT solver, Z3~\cite{de2008z3}, to check whether one guard condition implies another. For a Stack Overflow post with multiple method-level code snippets, {\tool} inlines invoked methods before extracting the call sequence in order to emulate a lightweight inter-procedural analysis. {\tool} is capable of detecting three types of API usage violations---{\em missing control constructs}, {\em missing or incorrect order of API call}, and {\em incorrect precondition}.

%When {\soa} encounters a new API that does not exist in its database, it automatically issues another mining request and expands the database with the new patterns it finds. Specifically, {\soa} utilizes a distributed software mining infrastructure, Boa \todo{cite} to traverse the abstract syntax trees (ASTs) of 7 million Java projects, collected September 2015 from GitHub. For every AST method, {\soa} checks if it is from the API of interest. If it is, {\soa} translates the code snippet into a structured call sequence. From these call sequences, {\soa} finds a common subsequence which is the required pattern for that API method, and this is added to the database.
%\todo{It is not necessary to describe how we wrap the data and communicate with the front-end. Please shorten this paragraph.}

%{\bf Popup Generation.} Using the data from the server's JSON message, the plug-in searches the identified code snippet for the API call in question, highlights it, and generates a Bootstrap popover on it, as seen in Figure~\ref{fig:features}. The popover is populated with a violation message describing the pattern being violated and including the GitHub support for the required pattern, in terms of number of supporting projects as well as three links to relevant GitHub pages using that pattern correctly. The plug-in generates one popover for each API call, and generates pages of the popover for each different pattern being violated by that call.

{\bf Warning message generation.}

{\bf Fix suggestion.} \todo{Describe how we generate a correct example based on the context of the assessed SO example to demonstrate the correct API usage?}

{\bf GitHub Example Alteration.} When the user clicks on a provided GitHub example in the popup, the plug-in's main script writes the name of the method call associated with that link to a shared storage space for the Chrome extension, using the {\tt chrome.storage} API. The script highlights the entire method and scrolls the view down so the user is easily able to find it, as seen in Figure~\ref{fig:github_examples}.