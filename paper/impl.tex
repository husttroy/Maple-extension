\section{Implementation}
\label{sec:implementation}

This section describes the tool implementation details of {\tool}. Figure~\ref{fig:arch} shows the architecture of {\tool}. The API usage mining process is computed offline and the resulting patterns are stored in a database. The technical details and evaluation of the mining technique is presented in~\cite{zhang2018code}. When a user loads a Stack Overflow page in the Chrome browser, the Chrome extension extracts code snippets within {\ttt <code>} tags in answer posts, and sends them to the back-end server. The back end then detects API usage violations in a snippet and synthesizes the warning messages and corresponding fixes. For each misused method call in a snippet, the Chrome extension generates a pop-up window using the Bootstrap popover plug-in\footnote{\url{https://www.w3schools.com/bootstrap/bootstrap_popover.asp}} to inform the user about the API misuse information.


\begin{table*}[!th]
\centering
\resizebox{\textwidth}{!}{%
\begin{tabular}{|l|l|l|}
\hline
\multicolumn{1}{|c|}{\sf Violation Type}    & \multicolumn{1}{c|}{\sf Description Template}                                                                                                  & \multicolumn{1}{c|}{\sf Example Warning Message}                                                                                                  \\ \hline
Missing/Incorrect Order of API calls & You may want to call {\bf \textless?\textgreater} {\bf \textless before/after\textgreater} calling {\bf \textless?\textgreater}                   & \begin{tabular}[c]{@{}l@{}}You may want to call {\ttt TypedArray.recycle()} after calling\\ {\ttt TypedArray.getString()}.  [\colorbox{lightgray}{\href{https://stackoverflow.com/questions/35784171}{35784171}}]\end{tabular}                                    \\ \hline
Missing Control Constructs              & You may want to call the API method {\bf \textless?\textgreater} in {\bf \textless?\textgreater}                           & \begin{tabular}[c]{@{}l@{}}You may want to call {\ttt Cursor.close()} in a finally block. [\colorbox{lightgray}{\href{https://stackoverflow.com/questions/31427468}{31427468}}]\end{tabular}                                                            \\ \hline
Missing Try-Catch                       & \begin{tabular}[c]{@{}l@{}} You may want to handle the potential {\bf \textless?\textgreater} exception thrown\\ by {\bf \textless?\textgreater} using a try-catch block\end{tabular} & \begin{tabular}[c]{@{}l@{}}You may want to handle the potential {\ttt SQLException} thrown by\\ {\ttt PreparedStatement.setString()} using a try-catch block. [\colorbox{lightgray}{\href{https://stackoverflow.com/questions/11183042}{11183042}}]\end{tabular} \\ \hline
Incorrect Guard Conditions              & You may want to check whether {\bf \textless?\textgreater} is true before calling {\bf \textless?\textgreater}                 & You may want to check whether {\ttt iterator.hasNext()} is true. [\colorbox{lightgray}{\href{https://stackoverflow.com/questions/25789601}{25789601}}]                                                          \\ \hline
\end{tabular}
}
\caption{Warning message templates for different types of API usage violations. {\textless?\textgreater} and {\textless before/after\textgreater} are instantiated based on API usage violations and correct patterns. The digits in the last column are the SO post ids of the warning examples.}
\label{tab:template}
\end{table*}

{\bf API Usage Pattern Dataset.} In our previous work~\cite{zhang2018code}, we mined API usage patterns of 100 popular Java API methods and carefully inspected 245 inferred patterns based on online documentation. As a result, we curated a dataset of 180 validated, correct patterns for API misuse detection. The overall mining precision is 73\%. These patterns are represented as API call sequences with surrounding control constructs. Each API call is also annotated with its argument types and guard conditions. For example, one pattern, {\ttt loop \{; get(int)@arg0$<$rcv.size(); \}}, checks if the index is out of bounds when calling the {\ttt get} method on an {\ttt ArrayList} object. %The mining algorithm and pattern format are described in~\cite{zhang2018code}. The current dataset can be extended with API usage patterns learned from other mining techniques~\cite{wang2013mining, gruska2010learning, Nguyen09}. 

{\bf API Misuse Detection.} The server first extracts the API call sequence of each SO snippet sent from the front end. We use a partial program analysis and type resolution framework to handle incomplete snippets and resolve ambiguous types~\cite{subramanian2014live}. {\tool} then queries the pattern database for the API calls present in each API call sequence. Given an API call sequence and an API usage pattern, it checks whether (1) the API calls and control constructs in the sequence follow the same temporal order in the pattern, and (2) the guard condition of each API call in the sequence implies the guard of the corresponding API call in the pattern. {\tool} uses a SMT solver, Z3~\cite{de2008z3}, to check whether one guard condition implies another. For a SO snippet with multiple methods, {\tool} inlines the call sequence of an invoked method into the sequence of the caller to emulate a lightweight inter-procedural analysis. {\tool} is capable of detecting three types of API usage violations---{\em missing control constructs}, {\em missing or incorrect order of API call}, and {\em incorrect guard condition}.

%When {\soa} encounters a new API that does not exist in its database, it automatically issues another mining request and expands the database with the new patterns it finds. Specifically, {\soa} utilizes a distributed software mining infrastructure, Boa \todo{cite} to traverse the abstract syntax trees (ASTs) of 7 million Java projects, collected September 2015 from GitHub. For every AST method, {\soa} checks if it is from the API of interest. If it is, {\soa} translates the code snippet into a structured call sequence. From these call sequences, {\soa} finds a common subsequence which is the required pattern for that API method, and this is added to the database.
%\todo{It is not necessary to describe how we wrap the data and communicate with the front-end. Please shorten this paragraph.}

%{\bf Popup Generation.} Using the data from the server's JSON message, the plug-in searches the identified code snippet for the API call in question, highlights it, and generates a Bootstrap popover on it, as seen in Figure~\ref{fig:features}. The popover is populated with a violation message describing the pattern being violated and including the GitHub support for the required pattern, in terms of number of supporting projects as well as three links to relevant GitHub pages using that pattern correctly. The plug-in generates one popover for each API call, and generates pages of the popover for each different pattern being violated by that call.

{\bf Warning message generation.} Given an API usage violation and the correct pattern, {\tool} generates a short warning message that describes the violation in natural language. Table~\ref{tab:template} shows the warning message templates for different types of API usage violations. In each template, {\textless?\textgreater} is instantiated with the corresponding API calls or control constructs based on the detected API usage violation and the correct pattern. {\textless before/after\textgreater} is instantiated based on the relative order of the two API calls in the correct pattern. The warning messages also describe which exception types are not handled in the snippets detected with {\em missing try-catch} violations. To help users understand the prevalence of a recommended API usage pattern, the warning message also quantifies how many other code fragments follow the same pattern in GitHub. 

{\bf Fix suggestion.} {\tool} further suggests a correct way of using an API method by synthesizing a readable fixed snippet based on the original SO snippet. {\tool} first matches each API call in the recommended API usage pattern with the given SO snippet. If an API call is matched, {\tool} reuses the same receiver object and arguments of the corresponding API call from the original SO snippet to the synthesized snippet. Otherwise, {\tool} names the receiver and arguments based on their types. For example, if the receiver type of an unmatched API call (i.e., a {\em missing-API-call} violation) is {\ttt File}, {\tool} names the receiver object as {\ttt file}, the lower case of the receiver type. In this way, {\tool} reduces the mental gap for switching between the original SO post and the recommended snippet.

%{\bf GitHub Example Alteration.} When the user clicks on a provided GitHub example in the popup, the plug-in's main script writes the name of the method call associated with that link to a shared storage space for the Chrome extension, using the {\tt chrome.storage} API. The script highlights the entire method and scrolls the view down so the user is easily able to find it, as seen in Figure~\ref{fig:github_examples}.