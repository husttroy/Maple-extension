% ==============================================
% !TEX root = ./critics.tex
% ==============================================
\section{Related Work} 
% ~2 paragraphs from Maple's Related Work
{\bf Quality Assessment of Online Code Examples.} The quality of online code examples has been investigated from various perspectives, with the conclusion that such examples are largely unreliable in terms of resolvable, parsable, or compilable code. Dagenais and Robillard~\cite{dagenais2012recovering} find that 89\% of API names in online-forum code snippets are ambiguous and not easily resolved due to their incompleteness. Subramanian et al.~\cite{subramanian2013making} observe that 66\% of a corpus of 39,000 SO snippets are free-standing statements, lacking class or method declarations. Similarly, Yang et al.~\cite{yang2016query} find that out of 91,000 Java SO code snippets, only 3.89\% are parsable and 1\% are compilable. Zhou et al.~\cite{zhou2016api} observe that 86 of 200 accepted SO posts use deprecated APIs but only 3 of them are reported by other users. We previously performed a study {\todo cite Maple study} considering the implications of following such code examples verbatim and how this may encourage potential API misuse and lead to unexpected behavior in client programs.

{\bf API Usage Mining.} {\soa}'s API usage mining is described in further detail in {\todo cite the Maple paper?}. A large body of literature in API usage mining currently exists {\todo cite}, which uses a variety of techniques. However, to our knowledge these existing pattern mining techniques do not mine from massive code corpora with millions of projects. Gruska et al.~\cite{gruska2010learning} mines from the largest code corpus we are aware of, which comprises 6,000 Linux projects. Our pattern mining also uses a prediate mining technique to mine API call guard conditions in addition to API call ordering. To our knowledge, Ramanathan et al.~\cite{ramanathan2007static} and Nguyen et al.~\cite{nguyen2014mining} are the only other predicate mining techniques, and unlike these techniques we formalize the predicate equivalence problem as a satisfiability problem and leverage an SMT solver to group logically equivalent predicates during guard mining {\todo this last sentence is basically verbatim from the Maple paper because I don't know how to word it any differently...}

% use several sentences to describe Codota and also distinguish our tool from Codota.
{\bf Codota.} The Codota Code Browsing Assistant for Chrome\footnote{https://www.codota.com/code-browsing-assistant} analyzes Java and Android code snippets in web pages and enhances them with IDE-like features. A user may click on underlined code to view API documentation, references, and API-level compatibility issues, and may also save code snippets to view later in a CodeBox supported by Codota. {\soa}, which draws inspiration from this tool's user interface, instead focuses specifically on potential API misuse and does so by inferring common usage patterns from GitHub code projects, as opposed to using API documentation. {\soa} also uses code examples derived from required patterns as well as code examples in their original GitHub context to demonstrate a given pattern to a user as opposed to describing it with natural language or API documentation.

% ==================================================
\section{Summary}
\label{sec:summary}
% ==================================================

{\soa} is an approach to enriching code examples on Q\&A sites like Stack Overflow that incorporates API usage mining and user feedback. Programmers often use sites like Stack Overflow to understand API usage, but the reliability of the code examples on these forums is under question. This will reduce the need to cross-check sites for API usage questions and takes advantage of the benefits of using easy-to-understand code examples as opposed to API documentation for learning API usage by enhancing the examples already present in Stack Overflow while also providing other, more reliable ones. For future work, we would like to conduct a user study to evaluate the usefulness of {\tool}.